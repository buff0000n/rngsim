<html>
<!-- Full disclosure: JavaScript is not my forte and neither is CSS. -B -->
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<meta name="viewport" content="width=640, initial-scale=1">
<head>
    <title>Warframe RNG Simulator</title>
</head>
<!-- embedded favicon because why not -->
<link href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAANH5AADR+QGceVN3AAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAetJREFUeNqMkz+oklEYxp8jtw8xMVEX+fyzhAjdJkN0aHBICEIiPt2dBBFB3CJwsLi7qJuTOCjOYZAUOElg1JVMhwvaouXQDUoT8Wnxky+vdT3wDO857/M7vO97jiCJI5Z3PB4r8/lcdrvdH202WxPANwAAyf9quVw+SqfT3y0WCyVJotPpZKFQ+EzylCT2kx/W6/XX+Xz+U6PReEkykUqlpgC4r2w2+5XkHa35SSgU+ivJ4/HQbDbvYlmWORwOC5PJJFWtVt+2Wq13KuBBqVR6f+gmrVwuF1er1eOt58ZmszkFSVxcXDyLRCK/ZFlmrVbrybL8T0iz2XylLRsk0ev1zqLRKLvdbpGkLpPJfDlkNplMVBTlN0lZBegAYL1em8Ph8A+/3/8cwCYYDJ7vz1Gv1yMWi2E2m0kATOq+2JLukrTpdLo3ADAej596vd4XDocDkiQBAJLJJPr9PoQQ03K5fBvATwA4AQAhxLkQQoWarFarFAgEMBqNkEgkYLfb0el00G630el0zlTzoYd0L5fLTY1G465uIQSFEATAeDxOkvevNFFVpVLpXjfKYrH4QevRafokDYdD+bpPMRgM7ABuqrEWgCM/ltjqKuDIpZaD3RTUA5/Pd6koyi2DwbA+5FwsFid+v/9SC/gzAD0ZXxYwq1doAAAAAElFTkSuQmCC" rel="icon" type="image/png" />
<style type="text/css">
    /* general formatting */
    * {
        font-family: sans-serif;
        color: #B0B0B0;
    }
    body {
        background-color: #202020;
    }
    .title {
	    font-weight: bold;
	    font-size: 100%;
	    color: #80A0D0;
	    display: inline;
    }
    .titleBar {
        background-color: #404040;
        margin: 1ex;
        padding: 1ex;
        border-radius: 1ex;
        text-align: middle;
    }
    .titleBar .businessDiv {
        margin: 2ex 1ex 1ex 1ex;
    }
    .mainTitle {
	    font-weight: bold;
	    text-align: center;
	    font-size: 200%;
	    color: #FFFFFF;
    }
    .subTitle {
	    font-weight: bold;
	    text-align: center;
	    font-size: 150%;
	    color: #FFFFFF;
    }
    .label {
        color: #FFFFFF;
    }
    a {
        color: #8080FF
    }
    a:visited {
        color: #D080FF
    }
    ul {
        list-style-type: disc;
    }
    li {
        margin: 0ex 0ex 1ex 0ex;
    }

    /* help section formatting */
    #lotsOfWordsContainer, .footerContainer {
        background-color: #202020;
        margin: 1ex;
        padding: 1ex;
        border-radius: 1ex;
   	    text-align: center;
    }
    .lotsOfWords, .footer {
        max-width: 100ex;
        display: inline-block;
   	    text-align: left;
    }
    .footer {
	    font-weight: bold;
	    font-size: 100%;
    }
    .about {
        text-align: center;
    }
    h1, h2, h3, h4 {
        color: A0C0F0;
    }
    strong {
        color: 6080B0;
    }
    .warn, .warn * {
        color: D06040;
    }
    #TOC li {
        margin: 0;
    }

    /* notes formatting */
    .notes tr td {
        padding: 0.1ex 0.25ex 1ex 0.25ex;
        vertical-align: text-top;
    }
    .notes tr td:first-child {
        width: 33%;
        text-align: right;
    }
    /*
        For some unknown reason, the font size on moble devices is much smaller, but only on the first column on the
        notes tables. Work around using a media query for a coarse pointer (usually denotes a phone or tablet).
    */
    @media only screen and (pointer: coarse) {
        .notes tr td:first-child {
            font-size: 150%;
        }
    }

    /* error bar formatting */
    #errorBar {
	    text-align: center;
    }
    #error {
        background-color: #B00000;
	    font-weight: bold;
	    text-align: left;
	    color: #FFFFFF;
        margin: 1ex;
        padding: 1ex;
        border-radius: 1ex;
        display: inline-block;
    }
    .errorLine {
	    font-weight: bold;
	    color: #FFFFFF;
    }

    /* general view formatting */
    .modelTitle {
	    font-weight: bold;
	    font-size: 150%;
	    color: #80A0D0;
	    display: inline;
    }
    #scenario {
        text-align: center;
    }
    .scenarioDiv {
        display: inline-block;
        text-align: left;
    }

    #scenario .missionTable {
        margin: auto;
    }
    #scenarioResults, .resultsTable {
        margin: auto;
	}
	.resultsTable {
        border-width: 0.25ex 0ex 0ex 0ex;
        border-style: solid;
        border-color: #80A0D0;
        padding: 1ex;
	}
    .worstCase {
        margin-left: 4ex;
        font-size: 75%;
        color: 808080;
    }
    .drop, .item, .mission, .add, .enemy, .rivenRoll, .rivenFieldTable {
        border-width: 0ex 0ex 0ex 0.25ex;
        border-style: solid;
        border-color: #80A0D0;
        color: #FFFFFF;
        margin: 0ex 0ex 0ex 3ex;
        padding: 0ex 0ex 0ex 3ex;
	}
    .mission, .enemy, .rivenRoll {
        border-width: 0.25ex 0ex 0ex 0.25ex;
    }
    .missionTable {
        margin: 1ex 1ex 1ex 3ex;
	}
    #scenario .fieldTable {
        width: 50ex;
    }

    /* Buttons */
    .button {
        margin: 1ex 1ex 1ex 1ex;
        cursor: pointer;
	}
	.utilGroup {
	    text-align: center;
	}
    .button, .examplesDiv, .stopAfterDiv, .autoStartDiv, .start, .stop, .urlButton {
        background-color: #808080;
        border: none;
        color: #FFFFFF;
        padding: 1ex;
        text-align: center;
        text-decoration: none;
        font-size: 100%;
        border-radius: 1ex;
    }
    .start {
        background-color: #60A060;
    }
    .stop {
        background-color: #A06060;
    }
    .delete, .clear {
        background-color: #604040;
    }
    .addButton {
        background-color: #404060;
    }
    .urlButton, .examplesDiv, .autoStartDiv {
        background-color: #406080;
    }
    .stopAfterDiv {
        background-color: #404040;
    }
    .stopAfterDiv input {
        /* why is the auto stop text box so hard to center? */
        vertical-align: 15%;
    }
    .density, .cumulative, .query {
        background-color: #404040;
        color: #D0D0D0;
    }
    .densitySelected, .cumulativeSelected, .querySelected {
        background-color: #80A0D0;
        color: #FFFFFF;
    }

    /* Fields */
    .inputName, .inputTime, .inputRequired, .inputCount, .inputRate, .inputRange, .inputStopAfter, .inputResult, .inputPercentile, .inputOdds, .inputPreventDupes {
        background-color: #101010;
        border: none;
        color: #B0B0B0;
        font-size: 75%;
        padding: 1ex;
        border-radius: 1ex;
    }
    .inputBailEarly, #copyUrlAutoStart {
        background-color: #101010;
        border: none;
        color: #B0B0B0;
    }
    #samplesSelect, .rivenTypeSelect {
        background-color: #101010;
        border: none;
        color: #B0B0B0;
        font-size: 100%;
        padding: 1ex;
        border-radius: 1ex;
    }

    /* graying everthing out when disabled */
    .rivenTypeSelect:disabled {
        background-color: #202020;
    }
    .button:disabled {
        background-color: #404040;
        color: #B0B0B0;
        cursor: not-allowed;
    }
    .inputName:disabled, .inputTime:disabled, .inputRequired:disabled, .inputCount:disabled, .inputRate:disabled, .inputRange:disabled, .inputStopAfter:disabled, .inputResult:disabled, .inputPercentile:disabled, .inputPreventDupes:disabled {
        background-color: #202020;
        color: #B0B0B0;
        cursor: not-allowed;
    }
    .inputStopAfter:disabled {
        background-color: #404040;
    }
    .inputBailEarly:disabled, #copyUrlAutoStart:disabled {
        background-color: #202020;
        color: #B0B0B0;
        cursor: not-allowed;
    }
    #samplesSelect:disabled {
        background-color: #202020;
        color: #B0B0B0;
        cursor: not-allowed;
    }

    /* results formatting */
    .missionResults, .trialResult table tr td, .timeResult table tr td, .notes tr td {
        vertical-align: text-top;
    }
    .statsTable {
        width: 100%;
    }
    .statsTable tr td:first-child {
        width: 25ex;
    }
    .rivenStatTable td {
        padding: 0ex 1ex;
    }
    .util, .utilHidden {
        margin: 1ex 0ex 1ex 0ex;
    }
    .util {
        display: inline;
    }
    .utilHidden {
        display: none;
    }
    /*
        Huge hack to configure the histogram chart through CSS
        The 'content' property can contain anything, does not affect a <canvas> element, and can be read by javascript
        using getComputedStyle()

        bg: background color
        l: line color
        t: text color
        to: text outline color
        b: bar color
        b90: bar color for >90%
        b99: bar color for >99%
        bh: bar highlight color
        bhbg: bar highlight background color
        fs: font size
    */
    .histogram {
        content: "bg=#202020;l=#B0B0B0;t=#B0B0B0;to=#202020;b=#80A0D0;b90=#FFFFA0;b99=#FFC0A0;bh=#C0D0FF;bhbg=#204050;fs=15";
    }

    /* query section */
    .histogramSettings div .tooltip {
        vertical-align: top;
    }

    /* tooltips, adapted from https://www.w3schools.com/css/css_tooltip.asp */

    .tooltip {
        position: relative;
        display: inline-block;
    }
    .tooltip:hover .tooltiptext, .tooltip:hover .tooltiptextbottom  {
        visibility: visible;
        opacity: 1;
    }
    /* fix the link colors inside tooltips */
    .tooltip a {
        color: #0000FF
    }
    .tooltip a:visited {
        color: #B000FF
    }

    /* right side tooltip */
    .tooltip .tooltiptext {
        visibility: hidden;
        width: 50ex;
        background-color: #FFFFFF;
        color: #4040A0;
        text-align: center;
        border-radius: 0.5ex;
        padding: 1ex;
        position: absolute;
        z-index: 1;
        top: 1ex;
        left: calc(100% + 2ex);

        opacity: 0;
        transition: opacity 500ms;
        transition-delay: 1s;
    }
    .tooltip .tooltiptext::after {
        content: "";
        position: absolute;
        top: 2.25ex;
        right: 100%;
        margin-top: -1ex;
        border-width: 1ex;
        border-style: solid;
        border-color: transparent #FFFFFF transparent transparent;
    }

    /* bottom side tooltip */
    .tooltip .tooltiptextbottom {
        visibility: hidden;
        width: 30ex;
        background-color: #FFFFFF;
        color: #4040A0;
        text-align: center;
        border-radius: 0.5ex;
        padding: 1ex;
        position: absolute;
        z-index: 1;
        top: 120%;
        left: calc(50% - 15ex);
        margin-left: -2ex;

        opacity: 0;
        transition: opacity 500ms;
        transition-delay: 1s;
    }
    .tooltip .tooltiptextbottom::after {
        content: "";
        position: absolute;
        bottom: 100%;  /* At the top of the tooltip */
        left: 50%;
        margin-left: -1ex;
        border-width: 1ex;
        border-style: solid;
        border-color: transparent transparent #FFFFFF transparent;
    }

    /* popup, adapted from https://www.w3schools.com/howto/howto_js_popup.asp */
    .popup {
        position: relative;
        display: inline-block;
        cursor: pointer;
    }
    .popup .popuptext {
        visibility: hidden;
        width: 50ex;
        background-color: #FFFFFF;
        color: #000080;
        text-align: center;
        border-radius: 0.5ex;
        padding: 1ex;
        position: absolute;
        z-index: 1;
        top: 120%;
        left: -40ex;
        margin-left: -2ex;
    }
    .popup .popuptext::after {
        content: "";
        position: absolute;
        bottom: 100%;  /* At the top of the tooltip */
        right: 2ex;
        margin-left: -1ex;
        border-width: 1ex;
        border-style: solid;
        border-color: transparent transparent #FFFFFF transparent;
    }
    .popup .show {
        visibility: visible;
        animation: fadeIn 1s
    }
    #urlHolder {
        color: #000000;
    }

    /* custom checkbox, adapted from https://www.w3schools.com/howto/howto_css_custom_checkbox.asp */
    .container {
        display: inline;
        position: relative;
        padding: 0ex 3ex;
        margin-bottom: 2ex;
        cursor: pointer;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }

    /* Hide the browser's default radio button */
    .container input {
        position: absolute;
        opacity: 0;
    }

    /* Create a custom radio button */
    .checkmark, .checkmarkHelp {
        padding: 0.2ex 1ex;
        border-radius: 0.5ex;
	    font-weight: bold;
	    color: #FFFFFF;
        background-color: #101010;
    }
    .checkmark {
        position: absolute;
        top: 0;
        left: 0;
    }

    /* On mouse-over, add a grey background color */
    .container:hover input ~ .checkmark {
        background-color: #808080;
    }

    /* When the radio button is checked, add a colored background */
    .container input:checked ~ .checkmark.positiveLock, .positiveLockHelp {
        background-color: #2020F0;
    }
    .container input:checked ~ .checkmark.positiveReq, .positiveReqHelp {
        background-color: #20F020;
    }
    .container input:checked ~ .checkmark.positive, .positiveHelp {
        background-color: #208020;
    }
    .container input:checked ~ .checkmark.dontcare, .dontcareHelp {
        background-color: #404040;
    }
    .container input:checked ~ .checkmark.negative, .negativeHelp {
        background-color: #802020;
    }
    .container input:checked ~ .checkmark.negativeReq, .negativeReqHelp {
        background-color: #F02020;
    }
    .container input:checked ~ .checkmark.negativeLock, .negativeLockHelp {
        background-color: #808020;
    }

    /* When the radio button is checked and disabled, add a lighter gray background */
    .container input:checked:disabled ~ .checkmark {
        background-color: #606060;
    }

    /* When the radio button is disabled and not checked, make the background the same as the page background */
    .container input:disabled ~ .checkmark {
        background-color: #202020;
    }

    /* keep the stat line from wrapping */
    .statPriorityGroup, .container, .checkmark, .label, .rivenCriterionNode td {
        white-space: nowrap;
    }

</style>
<script type="text/javascript" language="javascript" src="js/arrayutils.js"></script>
<script type="text/javascript" language="javascript" src="js/droptable.js"></script>
<script type="text/javascript" language="javascript" src="js/analysis.js"></script>
<script type="text/javascript" language="javascript">

    //==============================================================
	// Data model
    //==============================================================

    // formatting characters for serializing/deserializing the scenario configuration
	FIELD_SEP = '_';
	GROUP_START = '{';
	GROUP_END = '}';

    // config model for a single item
	class Item {
	    constructor() {
    		this.name = "Item";
    		this.prob = 10.0;
    		this.range = new Range();
    		this.required = 1;
    		this.inARow = false;
        }

		toString() {
		    // serialize to a string
			return writeName(this.name)
			    + FIELD_SEP + this.prob.toFixed(4)
			    + FIELD_SEP + this.range.toString()
			    + FIELD_SEP + (this.inARow ? "-" : "") + this.required;
		}

        setRequired(req) {
			if (req < 0) {
			    this.required = -req;
			    this.inARow = true;
			} else {
			    this.required = req;
			    this.inARow = false;
			}
        }

		fromString(s) {
		    // deserialize from a string
			var fields = split(s);
			if (fields.length != 4) {
				throw "Invalid format: \"" + s + "\"";
			}
			this.name = readName(fields[0]);
			this.prob = readFloat(fields[1]);
			this.range = new Range().fromString(fields[2]);
			this.setRequired(readIntWithNegative(fields[3]));
			return this;
		}
	}

    // config model for a single drop
	class Drop {
	    constructor() {
            this.name = "A";
            this.items = Array();
            this.dropsPerMission = 1;
            this.time = 0;
            this.requiredItems = 0;
            this.preventConsecutiveDupes = 0;
            this.preventConsecutiveDupesAppliesToNew = false;
        }

		add(item) {
			this.items.push(item);
		}

		toString() {
		    // serialize to a string
		    var s = writeName(this.name) + FIELD_SEP;
			s += this.dropsPerMission + FIELD_SEP;
			s += this.requiredItems + FIELD_SEP;
			s += this.time + FIELD_SEP;
			s += this.preventConsecutiveDupesAppliesToNew ? -this.preventConsecutiveDupes : this.preventConsecutiveDupes;
			for (var i = 0; i < this.items.length; i++) {
				s += FIELD_SEP + GROUP_START + "i_" + this.items[i].toString() + GROUP_END;
			}
			return s;
		}

		fromString(s) {
		    // deserialize from a string
			var fields = split(s);
			if (fields.length < 5) {
				throw "Invalid format: \"" + s + "\"";
			}
			this.name = readName(fields[0]);
   			this.dropsPerMission = readInt(fields[1]);
			this.time = readInt(fields[3]);
			var itemStart = 4;
			if (!fields[itemStart].startsWith("i_")) {
			    if (fields[itemStart] == "y")
    			    this.preventConsecutiveDupes = 1;

                else {
                    var p = readIntWithNegative(fields[itemStart]);
                    if (p < 0) {
                        this.preventConsecutiveDupes = -p;
                        this.preventConsecutiveDupesAppliesToNew = true;

                    } else {
                        this.preventConsecutiveDupes = p;
                        this.preventConsecutiveDupesAppliesToNew = false;
                    }
                }
    			itemStart++;
			}
			for (var i = 4; i < fields.length; i++) {
			    if (fields[i].startsWith("i_")) {
    				this.add(new Item().fromString(fields[i].substring(2)));
    			}
			}

            // read this after adding the items
			var req = readInt(fields[2]);
			if (req > 0) {
                this.requiredItems = Math.min(req, this.items.length);
			}

			return this;
		}
	}

    // config model for a single mission
	class Mission {
    	constructor() {
    		this.name = "Mission";
    		this.drops = Array();
    		this.requiredDrops = 0;
    		this.time = 0;
    		this.bailEarly = true;
    	}

		add(drop) {
			this.drops.push(drop);
		}

		getNumDrops() {
            // add up the total number of drops, taking into account drops that repeat more than once
			var numDrops = 0;
			for (var i = 0; i < this.drops.length; i++) {
				numDrops += this.drops[i].dropsPerMission;
			}
			return numDrops;
		}

        hasTime() {
            if (this.time > 0) {
                return true;
            }
			for (var r = 0; r < this.drops.length; r++) {
				if (this.drops[r].time > 0) {
				    return true;
				}
	        }
	        return false;
        }

		toString() {
		    // serialize to a string
		    var s = writeName(this.name) + FIELD_SEP;
			s += this.requiredDrops + FIELD_SEP;
			s += this.time + FIELD_SEP;
			s += this.bailEarly ? "y" : "n";
			for (var i = 0; i < this.drops.length; i++) {
				s += FIELD_SEP + GROUP_START + "d_" + this.drops[i].toString() + GROUP_END;
			}
			return s;
		}

		fromString(s) {
		    // deserialize from a string
			var fields = split(s);
			if (fields.length < 5) {
				throw "Invalid format: \"" + s + "\"";
			}
			this.name = readName(fields[0]);
			this.time = readInt(fields[2]);
			this.bailEarly = fields[3].toLowerCase() == "y";
			for (var i = 4; i < fields.length; i++) {
			    if (fields[i].startsWith("d_")) {
    				this.add(new Drop().fromString(fields[i].substring(2)));
    		    }
			}

            // read this after adding the drops
			var req = readInt(fields[1]);
			if (req > 0) {
                this.requiredDrops = Math.min(req, this.drops.length);
			}

			return this;
		}
	}

    // config model for the full list of missions
	class Scenario {
	    constructor() {
            this.name = "Scenario";
            this.missions = Array();
        }

		add(mission) {
			this.missions.push(mission);
		}

        hasTime() {
			for (var m = 0; m < this.missions.length; m++) {
				if (this.missions[m].hasTime()) {
				    return true;
				}
	        }
	        return false;
        }

		toString() {
		    // serialize to a string
			var s = writeName(this.name);
			for (var i = 0; i < this.missions.length; i++) {
				s += FIELD_SEP + GROUP_START +
				    (this.missions[i] instanceof Enemy ? "e_" :
				     this.missions[i] instanceof Mission ? "m_" :
				     this.missions[i] instanceof RivenRoll ? "r_" : "_") +
				    this.missions[i].toString() + GROUP_END;
			}
            return s;
		}

		fromString(s) {
		    // deserialize from a string
			var fields = split(s);
			if (fields.length < 2) {
				throw "Invalid format: \"" + s + "\"";
			}
			this.name = readName(fields[0]);
			for (var i = 1; i < fields.length; i++) {
			    if (fields[i].startsWith("m_")) {
    				this.add(new Mission().fromString(fields[i].substring(2)));

			    } else if (fields[i].startsWith("e_")) {
    				this.add(new Enemy().fromString(fields[i].substring(2)));

			    } else if (fields[i].startsWith("r_")) {
    				this.add(new RivenRoll().fromString(fields[i].substring(2)));
    			}
			}

			return this;
		}
	}

    function readScenario(s) {
        return new Scenario().fromString(s);
    }

    function writeScenario(scenario) {
        return scenario.toString();
    }

    //==============================================================
    // Enemy data model
    //==============================================================

    // This is just a simplifying wrapper around the Mission-based scenario
    class Enemy extends Mission {
        constructor() {
            super();

            // create a singleton Drop Event
            var drop = new Drop();
            drop.name = "Kill";
			this.drops.push(drop);
        }

        add(drop) {
            // make sure there is only one Drop Event
            this.drops[0] = drop;
        }
    }

    //==============================================================
    // Riven Roll data model
    //==============================================================

    // "database" of Riven stats.  Stats are identified by their index in this list.
    // The second value is a list of flags saying where the stat is applicable:
    //  g: gun
    //  m: melee
    //  p: positive stat
    //  n: negative stat
    //  r: reverse description, i.e. + is bad and - is good.
    var rivenStatList = Array(
        /* 00 */ ["Ammo maximum", "gpn"],
        /* 01 */ ["Attack Speed", "mpn"],
        /* 02 */ ["Damage vs Corpus", "gmpn"],
        /* 03 */ ["Damage vs Grineer", "gmpn"],
        /* 04 */ ["Damage vs Infested", "gmpn"],
        /* 05 */ ["Initial Combo", "mp"],
        /* 06 */ ["Melee Combo Efficiency", "mpn"],
        /* 07 */ ["Cold Damage", "gmp"],
        /* 08 */ ["Combo Duration", "mpn"],
        /* 09 */ ["Critical Chance", "gmpn"],
        /* 10 */ ["Critical Chance on Slide Attack", "mpn"],
        /* 11 */ ["Critical Damage", "gmpn"],
        /* 12 */ ["Damage", "gmpn"],
        /* 13 */ ["Electric Damage", "gmp"],
        /* 14 */ ["Heat Damage", "gmp"],
        /* 15 */ ["Finisher Damage", "mpn"],
        /* 16 */ ["Fire Rate", "gpn"],
        /* 17 */ ["Flight Speed", "gpn"],
        /* 18 */ ["Impact Damage", "gmpn"],
        /* 19 */ ["Magazine Capacity", "gpn"],
        /* 20 */ ["Multishot", "gpn"],
        /* 21 */ ["Toxin Damage", "gmp"],
        /* 22 */ ["Punch Through", "gp"],
        /* 23 */ ["Puncture Damage", "gmpn"],
        /* 24 */ ["Range", "mpn"],
        /* 25 */ ["Reload Speed", "gpn"],
        /* 26 */ ["Slash Damage", "gmpn"],
        /* 27 */ ["Status Chance", "gmpn"],
        /* 28 */ ["Status Duration", "gmpn"],
        /* 29 */ ["Recoil", "gpnr"],
        /* 30 */ ["Zoom", "gpn"],
    );

    // For now, the locked options are only enabled if you open a scenario link where they are alread present.  It was
    // the laziest way to enable and disable these.
    var lockedEnabled = false;

    // Anecdotally, there seems to be a basic 50-50 chance of either 2 or 3 positives.
    // Define it this way so we can use the exact same RNG code to determine the number of positive stats
    var rivenPositiveNumProbs = [0, 0, 50, 100];

    // Likewise, there seems to be a basic 50-50 chance of either 0 or 1 negative.
    // Define it this way so we can use the exact same RNG code to determine the number of negative stats
    var rivenNegativeNumProbs = [50, 100];

    // Get the name for the given stat
    function getStatName(stat) {
        return rivenStatList[stat][0];
    }

    // determine whether the given stat has the given flag
    function statHasFlag(stat, flag) {
        return rivenStatList[stat][1].indexOf(flag) >= 0;
    }

    // produce a list of all the stats with the given flag or flags
    function getRivenStatGroup(flags) {
        // todo: cache
        var group = Array();
        for (var i = 0; i < rivenStatList.length; i++) {
            var match = true;
            for (var j = 0; j < flags.length; j++) {
                if (!statHasFlag(i, flags[j])) {
                    match = false;
                    break;
                }
            }
            if (match) {
                group.push(i);
            }
        }
        return group;
    }

    // config model for criteria for a successful Riven roll.  The per-stat criteria is a list the size of the stat
    // database; the value at each index indicates the priority for the corresponding stat.  The priorities are:
    //   P: required positive
    //   p: wanted positive
    //   N: required negative
    //   n: wanted negative
    //   d: don't care
    //   L: locked positive
    //   l: locked negative
    //   -: not applicable (rifle only with melee riven or vice versa)

	class RivenCriterion {
    	constructor() {
    		this.name = "Criteria";
    		this.requiredNumPositives = -1;
    		this.requiredNumNegatives = -1;
    		// each index corresponds to the same index in rivenStatList
    		this.statPriority = Array(rivenStatList.length);
    		// initialize to N/A
    		for (var i = 0; i < rivenStatList.length; i++) {
    		    this.statPriority[i] = "-";
    		}
    		this.repeats = 1;
    	}

        hasTime() {
            // fitting into the Mission model interface, there is no time data
	        return false;
        }

        getStats(priority) {
            // gets the stats with the given priority
            var stats = Array();
            for (var i = 0; i < this.statPriority.length; i++) {
                if (this.statPriority[i] == priority) {
                    stats.push(i);
                }
            }
            return stats;
        }

        updatePriorities() {
            // break out out the stat priority list into separate lists of stat indices for each priority
            // do this lazily and cache it
            if (!this.requiredPositives) {
                this.requiredPositives = this.getStats("P");
                this.wantedPositives = this.getStats("p");
                this.lockedPositives = this.getStats("L");
                this.requiredNegatives = this.getStats("N");
                this.wantedNegatives = this.getStats("n");
                this.lockedNegatives = this.getStats("l");
                this.dontcares = this.getStats("d");
                // total number of applicable stats is the total number of all stats minus the N/A ones
                this.numStats = this.statPriority.length - this.getStats("-").length;

                this.applicableStats = Array();
                this.applicableStats["p"] = this.getNumApplicableStats0("p");
                this.applicableStats["n"] = this.getNumApplicableStats0("n");
            }
        }

        // get the number of stats that are for this Riven type and the given "p" or "n" flag
        getNumApplicableStats(flag) {
            return this.applicableStats[flag];
        }

        getNumApplicableStats0(flag) {
            var count = 0;
            for (var i = 0; i < this.statPriority.length; i++) {
                if (this.statPriority[i] != "-" && statHasFlag(i, flag)) {
                    count++;
                }
            }
            return count;
        }

        // get the numbered stat that is for this Riven type, and the given "p" or "n" flag, and not already in use
        getApplicableStat(index, skip, flag) {
            var count = 0;
            for (var i = 0; i < this.statPriority.length; i++) {
                // priority of "-" means it's N/A, missing the flag basically means it's an exluded negative stat, and
                // appearing in the skip array means it's already been used.
                var n1 = this.statPriority[i];
                var n2 = statHasFlag(i, flag);
                var n3 = skip.indexOf(i);
                if (this.statPriority[i] != "-" && statHasFlag(i, flag) && skip.indexOf(i) == -1) {
                    // found our count, return the identifying stat index
                    if (count == index) {
                        return i;
                    }
                    count++;
                }
            }
            return -1;
        }

        verify(type) {
            // make sure the state is updated
            this.updatePriorities();
            var errors = Array();
            // sanity check on the size of the stat priorities list.
            var rivenStatGroup = getRivenStatGroup(type);
            if (rivenStatGroup.length != this.numStats) {
                errors.push("wrong number of stat priorities");
            }

            // sanity check on the contents of the stat priorities list
            for (var i = 0; i < this.statPriority.length; i++) {
                if ("PpdnN-Ll".indexOf(this.statPriority[i]) < 0) {
                    errors.push("invalid priority: " + this.statPriority[i]);
                }
            }

            // verification of the positive and negative sides are identical
            errors = this.verifySide(errors, "positive", this.requiredNumPositives, this.requiredPositives, this.lockedPositives, rivenPositiveNumProbs);
            errors = this.verifySide(errors, "negative", this.requiredNumNegatives, this.requiredNegatives, this.lockedNegatives, rivenNegativeNumProbs);

            // super tough corner case: verify that if they set Required Negatives to 1 then at least one stat must be allowed to be negative
            if (this.requiredNumNegatives > 0) {
                // union together all the possible negative stats
                var negatives = union(this.dontcares, union(this.requiredNegatives, union(this.wantedNegatives, this.lockedNegatives)));
                var foundPossibleNegatives = 0;
                // search the union for enough stats that actually support being negative to fulfill requiredNumNegatives
                for (var i = 0; i < negatives.length; i++) {
                    if (statHasFlag(negatives[i], "n")) {
                        foundPossibleNegatives++;
                    }
                }

                // no dice
                if (foundPossibleNegatives < this.requiredNumNegatives) {
                    errors.push("Required Negatives is " + this.requiredNumNegatives + ", at least " + this.requiredNumNegatives + " stat" + (this.requiredNumNegatives > 1 ? "(s)" : "") + " must be allowed to be negative");
                }
            }

            return errors;
        }


       verifySide(errors, name, requiredNum, required, locked, numProbs) {
            // check the number of required stats
            if (requiredNum > numProbs.length - 1) {
                errors.push("Too many required " + name + "s");

            // check the required num is too negative
            } else if (requiredNum < -1) {
                errors.push("Required " + name + "s is too low");

            // check if the required num is not a possible choice given the probability list
            // either it's 0 and the cumulative probability of 0 is 0%
            } else if ((requiredNum == 0 && numProbs[0] == 0) ||
                // or it's > 0 and the difference in cumulative probability between num and num - 1 is 0%, meaning there 
                // is a 0% change of RNG giving us this output
                    (requiredNum > 0 && numProbs[requiredNum] == numProbs[requiredNum - 1])) {
                errors.push("Required " + name + "s is invalid");
            }

            // make sure the number of locked stats isn't more than the possible number of stats
            if (locked.length > numProbs.length - 1 ||
                (requiredNum >= 0 && locked.length > requiredNum)) {
                errors.push("too many locked " + name + " stats");
            } else {
                // make sure the number of required stats isn't more than the possible number of stats minus the locked stats
                if (required.length > numProbs.length - 1 - locked.length ||
                    (requiredNum >= 0 && required.length - locked.length > requiredNum)) {
                    errors.push("too many required " + name + " stats");
                }
            }
            return errors;
       }

        accept(positiveList, negativeList) {
            // determine whether the given Riven stats meet this criteria

            // check against the required number of positive stats, if applicable        
            if (this.requiredNumPositives > -1 && this.requiredNumPositives != positiveList.length) {
                return false;
            }
            // check against the required number negative stats, if applicable        
            if (this.requiredNumNegatives > -1 && this.requiredNumNegatives != negativeList.length) {
                return false;
            }
            // make sure the state is updated
            this.updatePriorities();

            // make sure the intersection of the Riven positive stats and our wanted negative stats is empty
            if (intersection(positiveList, this.wantedNegatives).length > 0) {
                return false;
            }

            // see if the intersection of the Riven positive stats and our required positive stats includes all of our
            // required positive stats
            if (intersection(positiveList, this.requiredPositives).length < this.requiredPositives.length) {
                return false;
            }

            // pull out the leftover Riven positive stats after removing the required ones
            var leftoverPositives = difference(positiveList, this.requiredPositives);
            // also pull out the locked ones
            leftoverPositives = difference(leftoverPositives, this.lockedPositives);

            // intersect the leftover Riven positive stats with out wanted positive stats
            var positiveInt = intersection(leftoverPositives, this.wantedPositives);

            // If the size of that intersection is equal to the number of leftover Riven positive stats, then all of the 
            // Riven positive stats are wanted, so we're good.
            // Alternative, if the size of that intersection is equal to the wanted positive stats, then all of our 
            // wanted positive stats are present, so we're still good.
            if (positiveInt.length != leftoverPositives.length && positiveInt.length != this.wantedPositives.length) {
                return false;
            }

            // todo: simplify the negative stat checking since there can only be one of them

            // make sure the intersection of the Riven negative stats and our wanted positive stats is empty
            if (intersection(negativeList, this.wantedPositives).length > 0) {
                return false;
            }

            // see if the intersection of the Riven negative stats and our required negative stats includes all of our
            // required negative stats
            if (intersection(negativeList, this.requiredNegatives).length < this.requiredNegatives.length) {
                return false;
            }
            // pull out the leftover Riven negative stats after removing the required ones
            var leftoverNegatives = difference(negativeList, this.requiredNegatives);
            // also pull out the locked ones
            leftoverNegatives = difference(leftoverNegatives, this.lockedNegatives);

            // intersect the leftover Riven negative stats with out wanted negative stats
            var negativeInt = intersection(leftoverNegatives, this.wantedNegatives);

            // If the size of that intersection is equal to the number of leftover Riven negative stats, then all of the 
            // Riven negative stats are wanted, so we're good.
            // Alternative, if the size of that intersection is equal to the wanted negative stats, then all of our 
            // wanted negative stats are present, so we're still good.
            if (negativeInt.length != leftoverNegatives.length && negativeInt.length != this.wantedNegatives.length) {
                return false;
            }

            // nothing else to check, we're good!
            return true;
        }

		toString() {
		    // serialize to a string
		    var s = "";
			s += writeName(this.name) + FIELD_SEP;
			s += this.requiredNumPositives + FIELD_SEP;
			s += this.requiredNumNegatives + FIELD_SEP;
			// write the stat priority list as a simple character sequence, one per index
			for (var i = 0; i < this.statPriority.length; i++) {
			    s += this.statPriority[i];
			}
			if (this.repeats != 1) {
			    s += FIELD_SEP + this.repeats
			}
			return s;
		}

		fromString(s) {
		    // deserialize from a string
			var fields = split(s);
			if (fields.length != 4 && fields.length != 5) {
    			return null;
			}
			this.name = readName(fields[0]);
			this.requiredNumPositives = readIntWithDefault(fields[1], -1);
			this.requiredNumNegatives = readIntWithDefault(fields[2], -1);
			// read the stat priority list as a character sequence
			for (var i = 0; i < this.statPriority.length; i++) {
			    this.statPriority[i] = fields[3][i];

			    // If we parse a criterion containing any locked stats then enable locked stats in the UI
			    if ("L" == this.statPriority[i] || "l" == this.statPriority[i]) {
			        lockedEnabled = true;
			    }
			}

            if (fields[4]) {
                this.repeats = readIntWithDefault(fields[4], 1);
            }

			return this;
		}
	}

    // config model for a riven roll
	class RivenRoll {
    	constructor() {
    		this.name = "Riven Roll";
    		// g: Gun
    		// m: Melee
    		this.type = "g";
    		// list of RivenCriteria objects
    		this.criteria = Array();
    	}

        add(criterion) {
            this.criteria.push(criterion);
        }

		getNumDrops() {
		    // matching the Mission interface, we have 1 drop event.
    		return 1;
		}

        hasTime() {
		    // matching the Mission interface, there is no time info.
	        return false;
        }

		toString() {
		    // serialize to a string
		    var s = "";
			s += writeName(this.name) + FIELD_SEP;
		    s += writeName(this.type);
			for (var i = 0; i < this.criteria.length; i++) {
			    s += FIELD_SEP + GROUP_START + "c_" + this.criteria[i].toString() + GROUP_END;
			}
			return s;
		}

		fromString(s) {
		    // deserialize from a string
			var fields = split(s);
			if (fields.length < 3) {
    			return null;
			}
			this.name = readName(fields[0]);
			this.type = readName(fields[1]);
			for (var i = 2; i < fields.length; i++) {
			    if (fields[i].startsWith("c_")) {
			        this.add(new RivenCriterion().fromString(fields[i].substring(2)));
			    }
			}

			return this;
		}
	}

    // utility for creating an interesection of two lists
    function intersection(list1, list2) {
        var list3 = new Array();
        for (var i = 0; i < list1.length; i++) {
            if (list2.indexOf(list1[i]) >= 0) {
                list3.push(list1[i]);
            }
        }
        return list3;
    }

    // utility for creating a union of two lists
    function union(list1, list2) {
        var list3 = new Array();
        for (var i = 0; i < list1.length; i++) {
            list3.push(list1[i]);
        }
        for (var i = 0; i < list2.length; i++) {
            if (list1.indexOf(list2[i]) == -1) {
                list3.push(list2[i]);
            }
        }
        return list3;
    }

    // utility for subtracting one list from another
    function difference(list1, list2) {
        var list3 = new Array();
        for (var i = 0; i < list1.length; i++) {
            if (list2.indexOf(list1[i]) == -1) {
                list3.push(list1[i]);
            }
        }
        return list3;
    }

    //==============================================================
    // Misc data model utility functions
    //==============================================================

	function writeName(name) {
	    // filter out any of our special format characters and extra whitespace
	    var re = new RegExp("[" + FIELD_SEP + GROUP_START + GROUP_END + "\\s]", "g");
	    name = name.replace(re, " ");
	    // urlencode some things
	    name = name.replace(/%/g, "%25");
	    name = name.replace(/&/g, "%26");
	    name = name.replace(/\?/g, "%3F");
	    // replace whitespace with '+'

	    return name.replace(/ /g, "+");
	}

	function readName(name) {
	    // un-replace '+' with a space
	    name = name.replace(/\+/g, " ");
	    // urldecode some things
	    name = name.replace(/%25/g, "%");
	    name = name.replace(/%26/g, "&");
	    name = name.replace(/%3[Ff]/g, "?");
	    // no funny business
	    name = name.replace(/[<>\"]/g, "");
	    return name;
	}

	function readInt(intString) {
	    return readIntWithDefault(intString, 0);
	}

	function readIntWithDefault(intString, def) {
	    // read a number from a string and convert any errors or negative values to zero.
	    var i = Number.parseInt(intString);
	    if (Number.isNaN(i) || i < 0) {
	        return def;
	    }
	    return i;
	}

	function readIntWithNegative(intString) {
	    // read a number from a string and convert any errors or negative values to zero.
	    var i = Number.parseInt(intString);
	    if (Number.isNaN(i)) {
	        return def;
	    }
	    return i;
	}

	function readFloat(intString) {
	    // read a decimal from a string and convert any errors or negative values to zero.
	    var i = Number.parseFloat(intString);
	    if (Number.isNaN(i) || i < 0) {
	        return 0.0;
	    }
	    return i;
	}

	function split(s) {
	    // split a string according to the field separator characters
	    // when a group start character is encounted, ignore any separator characters until the corresponding 
	    // group end character is encountered.

		var list = Array();
		var groupCount = 0;
		var buffer = "";

		for (var i = 0; i < s.length; i++) {
			var c = s.charAt(i);
			switch (c) {
				case FIELD_SEP:
					if (groupCount == 0) {
					    // field separator hit and we're not inside a group: add the accumulated text to the list and clear it
						list.push(buffer);
						buffer = "";
					} else {
					    // field separator hit but we're not inside a group: add it to the accumulated text
						buffer = buffer + c;
					}
					break;
				case GROUP_START:
					if (groupCount > 0) {
					    // group started while we're already in a group: add it to the accumulated text
						buffer = buffer + c;
					} // otherwise we discard the outer group characters
					// increment the nested group count
					groupCount++;
					break;
				case GROUP_END:
					groupCount--;
					if (groupCount > 0) {
					    // group ended but we're still in a group: add it to the accumulated text
						buffer = buffer + c;
					} // otherwise we discard the outer group characters
					break;
				default:
				    // everything else: add it to the accumulated text
					buffer = buffer + c;
			}
		}
		// add the last accumulated text to the list
		if (buffer.length > 0) {
			list.push(buffer);
		}
		return list;
	}

    //==============================================================
    // Result Data Model
    //==============================================================

    // this class encapsulates the actual run data, along with some basic statistical analysis
	class TrialData {
	    constructor() {
	        // The raw data distribution.  This array represents a list of buckets, one for each possible number of
	        // runs a trial took.  The value of each bucket is the total number of trials that took that number of
	        // runs to complete.
            this.dist = Array();

            // The cumulative distribution.  Each bucket represents the number of trails that took less than or equal
            // to that number of runs to complete.
            this.cDist = Array();

            // In most of the cases with the time data, we don't need a bucket for each integer minute.  We just need
            // buckets for every five minute interval, or 20 minute intervals, etc.  This tracks the scaling
            // relationship between the distribution bucket indices and the actual result data.  When we get a result
            // that doesn't fit exactly into an existing bucket we will re-scale the distribution so it fits.
            // a value of 0 means the scale hasn't been initialized.  We'll initialize it when we receive the first
            // result.
            this.scale = 0;

            // sum of the runs from all the trials
            this.total = 0;

            // the smallest number of runs in any trial
            this.min = Number.MAX_SAFE_INTEGER;
            // A descriptive string from the trial with the smallest number of runs.
            this.minString = null;

            // the largest number of runs in any trial
            this.max = 0;
            // A descriptive string from the trial with the largest number of runs.
            this.maxString = null;

            // keep track of the largest bucket value
            this.maxBucketValue = -1;

            // the total number of trials.
            this.numTrials = 0;

            // statistics.  If the average is then zero it means these have not been calculated
            this.average = 0;
            this.standardDeviation;
            this.skew;
            this.kurtosis;
		}

		addResult(result, desc) {
		    // add the result from a single trial

		    // sanity check
		    if (!Number.isInteger(result)) {
		        throw "Invalid result: " + result;
		    }

            // make sure our distribution arrays are big enough and scaled appropriately for this trial's bucket
			this.ensureScaleAndSize(result);
			var bucket = result/this.scale;
			// increment our distibution's bucket corresponding to this trial's number of runs
			this.dist[bucket] += 1;
			// track the largest bucket
			if (this.maxBucketValue < this.dist[bucket]) {
			    this.maxBucketValue = this.dist[bucket];
			}
			// increment our cumulative distribution's bucket corresponding to this trial's number of runs, along with
			// every bucket greater than that.
			for (var i = bucket; i < this.cDist.length; i++) {
				this.cDist[i] += 1;
			}
			// add to our sum of all trials' runs
			this.total += result;
			// track the mininum number of runs
			if (result < this.min) {
				this.min = result;
				// store a string description of the minimum run
				this.minString = desc.toString();
			}
			// max is already set by ensureSize()
			if (result >= this.max) {
			    // track the maximum number of runs
				this.max = result;
				// store a string description of the maximum run
				this.maxString = desc.toString();
			}
			// increment the total number of trials
			this.numTrials++;

			// reset stats
			this.average = 0;
		}

		percentileToResult(fraction) {
		    // given a percentile as a fraction between 0 and 1, use our cumululative distibution to determine
		    // the number of runs corresponding to that percentile.

            // determine the cutoff point in number of trials
			var lookup = Math.round(this.numTrials * fraction);
			// if the cutoff is greater or equal to the total number of trials, then it's beyond our data set
			// just return the maximum number of runs
			if (lookup >= this.numTrials) {
				return this.max;
			}
			// search for either the exact cutoff value in our cumulative distribution, or the index where the cutoff
			// value would be inserted to remain sorted.
			var i = binarySearch(this.cDist, lookup);

            // found the exact cutoff in our cumulative distribution, this usually doesn't happen
			if (i >= 0) {
				return this.scale * (i + 0.5);
			}

            // found an insertion point, convert back to the index
			i = -(i + 1);
            // insertion point is index 0, so just return that, this also usually doesn't happen
			if (i == 0) {
				return this.scale * (this.cDist[0] / lookup);
			}

			// i is ths insertion point, so cDist[i] > lookup, and cDist[i - 1] < lookup
			// do a linear interpotation between the two, based on how far i is from one to the other.
			// finally, multiple by the scale since it's based on the bucket index
			return this.scale * ((i - 1) + ((lookup - this.cDist[i - 1]) / (this.cDist[i] - this.cDist[i - 1])));
		}

		resultToPercentile(result) {
		    // given a specific number of runs, determine how likely is is for a trial to take that number of
		    // runs or fewer.  Essentially, what percentile is this result?

            // beyond the end of our data: 100%
			if (result >= this.max) {
				return 1.0;
			}
			// get the cumulative number of trials that took that number of runs or fewer, divided by the total
			// number of trials
			var trials = this.cDist[result/this.scale];
			return trials / this.numTrials;
		}

		reCalc() {
		    // calculate statistics of the distribution

		    // already calculated
			if (this.average != 0) {
				return;
			}

			// average is easy, the total number of runs over all trials divided by the number of trials
			this.average = (this.total) / this.numTrials;

			// standard deviation is the square root of variance, which is the second moment
			// this describes how spread out the data is from the average
			this.standardDeviation = Math.sqrt(this.moment(2));

			// skew is the third moment divided by the cube of the standard deviation
			// this describes how far away the 50th percentile is from the average
			this.skew = this.moment(3) / Math.pow(this.standardDeviation, 3);

			// kurtosis is the fourth moment divided by the 4th power of the standard deviation, minus 3 for Excess Kurtosis
			// this basically describes how many extreme outliers there are compared to a normal distribution
			this.kurtosis = this.moment(4) / Math.pow(this.standardDeviation, 4) - 3;

			// mode is the most commonly occurring result.  in our case it's the largest bucket
			// This isn't very useful for huge, varied data sets like most RNG simulator results
			this.mode = this.calcMode()
		}

		moment(m) {
		    // basically, the mth moment is the average of the mth powers of the differences between each data value and the average.

		    // keep a sum
			var sum = 0;
			// iterate over each data value
			for (var t = 0; t <= this.max; t+=this.scale) {
			    // start with the difference from the average, which can be negative
				var d = (t - this.average);
				// raise the difference to the mth power
				var p = d;
				for (var i = 1; i < m; i++) {
					p *= d;
				}
				// add to the sum, we have to multiply by the number of results in the Tth bucket
				sum += (p * this.dist[t/this.scale]);
			}
			// divide by the number of data values for the average
			return sum / this.numTrials;
		}

		calcMode() {
            // track the current mode and its value
			var mode = 0;
			var modeValue = 0;
			// iterate over each data value
			for (var t = 1; t <= this.max; t+=this.scale) {
                var value = this.dist[t/this.scale];
                if (value > modeValue) {
                    mode = t;
                    modeValue = value;
                }
            }
			return mode;
		}

		ensureScaleAndSize(index) {
		    if (this.scale == 0) {
		        // scale is not initialized, let's start somewhere

		        // ugh the first result is zero.  Let's handle this the lazy way and just set the scale to 1.
		        if (index == 0) {
		            this.scale = 1;

		        } else {
		            // initialize the scale so it contains the first result in bucket 1.
                    this.scale = index;
                }

		        // assuming dist and cDist are still empty
		    }

		    // see if we have to rescale

		    if ((index % this.scale) != 0) {
		        // calculate a new scale that will hold all existing buckets and the new one by just finding the
		        // greatest common divisor of the current scale and the new bucket.

                var newScale = getGcd(index, this.scale);

                // rescale the distribution, filling new buckets with zeros
    			this.dist = this.ensureScale0(this.dist, this.scale, newScale, false);

                // rescale the cumulative distribution, filling new buckets with the cumulative value before them in the array
    			this.cDist = this.ensureScale0(this.cDist, this.scale, newScale, true);

    			// set the new scale
    			this.scale = newScale;
		    }

		    // make sure our dist and cumulative dist are bigh enough for the given bucket index

		    // fill any added buckets of the distribution with zeros
			this.dist = this.ensureSize0(this.dist, (index/this.scale) + 1, false);

		    // fill any added buckets of the cumulative distribution with the current last value
			this.cDist = this.ensureSize0(this.cDist, (index/this.scale) + 1, true);

			// update the maximum bucket
			if (index > this.max) {
				this.max = index;
			}
		}

        ensureScale0(list, scale, newScale, copyFill) {
            var multiple = scale / newScale;
            var newList = new Array();
            for (var i = 0; i < list.length; i++) {
                newList.push(list[i]);
                var fill = copyFill ? list[i] : 0;
                for (var j = 1; j < multiple; j++) {
                    newList.push(fill);
                }
            }
            return newList;
        }

		ensureSize0(list, size, copyFill) {
		    // if we're copying the last value in the array to fill it and there actually is a last value,
		    // then use that to fill the added indices, otherwise use zero
    	    var fill = (copyFill && list.length > 0) ? list[list.length - 1] : 0;

    	    // not sure how arrays in Javascript actually work.  Does this create a new internal array each time
    	    // we push an element?
			while (list.length < size) {
    			list.push(fill);
			}
			return list;
		}
	}

    function binarySearch(a, key) {
        return binarySearch0(a, 0, a.length, key);
    }

    function binarySearch0(a, fromIndex, toIndex, key) {
        // this is translated directly from Java's binary search implementation, because that's what I originally wrote
        // this program in

        var low = fromIndex;
        var high = toIndex - 1;

        while (low <= high) {
            var mid = (low + high) >>> 1;
            var midVal = a[mid];

            if (midVal < key)
                low = mid + 1;  // Neither val is NaN, thisVal is smaller
            else if (midVal > key)
                high = mid - 1; // Neither val is NaN, thisVal is larger
            else {
                if (midVal == key)     // Values are equal
                    return mid;             // Key found
                else if (midVal < key) // (-0.0, 0.0) or (!NaN, NaN)
                    low = mid + 1;
                else                        // (0.0, -0.0) or (NaN, !NaN)
                    high = mid - 1;
            }
        }
        return -(low + 1);  // key not found.
    }

	function getGcd(a, b) {
	    // easy case a == b
		if (a == b) {
			return a;
		}
		// make a > b
		if (a < b) {
			var c = a;
			a = b;
			b = c;
		}
		// oh look it's the Euclidean algorithm
		for (;;) {
			var c = a % b;
			if (c == 0) {
				return b;
			}
			if (c == 1) {
				return 1;
			}
			a = b;
			b = c;
		}
	}

    //==============================================================
    // Runner Model
    //==============================================================

    // data model for generating and tracking the results from running a single drop
	class DropRunner {
	    constructor(drop) {
            this.drop = drop;
            // the actual results from all the items in this drop
	        this.x = new Array(this.drop.items.length);
            // the results from other drops that have items with the same name.
	        this.otherx = new Array(this.drop.items.length);
	        // the number of successful items, determined by the item's required number.
            this.numSuccess = 0;
            // convert the list of individual probabilities for each item to a list of cumulative probabilities, in
            // order, from 0 to 1.
            // note that this will not go all the way to 1 if the sum of the drop's desired items do not add to 100%
			this.cProbs = toCumulativeProbs(this.drop.items);

			// need to keep track of the last item from this drop in order to cross reference with other
			// drops that may have the same item
			this.lastItem = null;
			// also track how many of the last item dropped
			this.lastItemCount = 0;

			// Only worry about history if preventConsecutiveDupes is enabled
			if (this.drop.preventConsecutiveDupes > 0) {
    			this.lastHistory = new Array();
    			this.lastNewHistory = new Array();
            }

    		// if the drop's required items is 0 then all items are required
            this.requiredItems = this.drop.requiredItems > 0 ? this.drop.requiredItems : this.drop.items.length;

			this.reset();
		}

		verify() {
		    var errors = Array();
		    if (this.drop.items.length == 0) {
		        errors.push("contains no items");
		    }
		    var dropNames = Array();
		    for (var d = 0; d < this.drop.items.length; d++) {
		        var item = this.drop.items[d];
		        if (item.prob <= 0 || item.prob > 100) {
    		        errors.push("item '" + item.name + "' -> invalid drop rate: '" + item.prob + "%'");
		        }
		        if (item.required == 0) {
    		        errors.push("item '" + item.name + "' -> required number is zero");
		        }
		        if (dropNames[item.name]) {
    		        errors.push("duplicate item name: '" + item.name + "'");

		        } else {
    		        dropNames[item.name] = item.name;
    		    }

    		    var rangeErrors = item.range.verify();
    		    for (var i = 0; i < rangeErrors.length; i++) {
    		        errors.push("item '" + item.name + "' -> range -> " + rangeErrors[i]);
    		    }
		    }
		    // need to have some leeway for rounding errors
		    if (this.cProbs[this.cProbs.length - 1] > 100.1) {
		        errors.push("drop rates add to more than 100%");
		    }
		    if (this.requiredItems > this.drop.items.length) {
		        errors.push("required items is greater than the number of items");
		    }
		    if (this.drop.dropsPerMission <= 0) {
		        errors.push("number of drops is zero");
		    }
		    if (this.drop.preventConsecutiveDupes >= this.drop.items.length) {
		        errors.push("Prevented Consecutive Repeats must be less than the number of drop items");
		    }
		    return errors;
		}

		reset() {
		    // reset the result data for a new run
	        for (var i = 0; i < this.x.length; i++) {
	            this.x[i] = 0;
	            this.otherx[i] = 0;
	        }
			this.numSuccess = 0;
			// clear history, if necessary
			if (this.drop.preventConsecutiveDupes > 0) {
    			this.lastHistory = new Array();
    			this.lastNewHistory = new Array();
            }
		}

		hasSucceeded() {
		    // the drop is successful if it has seen all of its required items over the course of the run
			return this.numSuccess >= this.requiredItems;
		}

		run() {
		    // This is where the actual RNG happens.

		    var i1;

            // this needs to be run in a loop because of preventConsecutiveDupes
            // Just repeating the RNG roll is quicker in most cases than building a custom cProbs table without the
            // duplicate results every time.
            for (;;) {
                // generate a random percentage between 0 and 100.
                var d = Math.random() * 100.0;
                // search our cumulative probability list for where the RNG decimal would be inserted
                i1 = binarySearch(this.cProbs, d);
                // convert the "not found" result to an index
                if (i1 < 0) {
                    i1 = -(i1 + 1);
                }

                // If we don't need to check history, or if our history does not include the current drop, then we
                // can exit the loop
                // check the appropriate history according to preventConsecutiveDupesAppliesToNew
                if (this.drop.preventConsecutiveDupes == 0 ||
                        (!this.drop.preventConsecutiveDupesAppliesToNew && !this.lastHistory.includes(i1)) ||
                        (this.drop.preventConsecutiveDupesAppliesToNew && !this.lastNewHistory.includes(i1))) {
                    break;

                } else {
                    "something".charAt(0);
                }
            }

			for (var i = 0; i < this.x.length; i++) {
			    // if the item's count must be in a row, and the item didn't drop, and its current count is
			    // less than the required count, then zero it out.
			    if (this.drop.items[i].inARow && i != i1 && this.x[i] < this.drop.items[i].required) {
			        this.x[i] = 0;
			    }
			}

			var ret = false;
			// if the index is not past the end of the cumulative probability list
			if (i1 < this.x.length) {
			    // one of our items successfuly dropped.  increment the corresponding count
			    var count = this.drop.items[i1].range.generate(this.drop.items[i1].required - (this.x[i1] + this.otherx[i1]));
				this.x[i1] += count;
	            // see if the total count has just now met or exceeded the required number
				if (this.x[i1] + this.otherx[i1] - count < this.drop.items[i1].required &&
				    this.x[i1] + this.otherx[i1] >= this.drop.items[i1].required) {
				    // if the item has hit its required number, increment the number of successful items
					this.numSuccess++;
					// if the number of successful items has hit the drop's required number successes, then
					// return success
					if (this.numSuccess == this.requiredItems) {
						ret = true;
					}
				}
				// Save the last result
				this.lastItem = this.drop.items[i1];
				this.lastItemCount = count;

				// track recent history, if necessary
				if (this.drop.preventConsecutiveDupes > 0) {
				    // add the last result to the end
				    this.lastHistory.push(i1);
				    // while we have more history than we need, remove the first/oldest element
				    while (this.lastHistory.length > this.drop.preventConsecutiveDupes) {
				        this.lastHistory.shift();
				    }
				    // if this is the first drop for the last result then add it to the last new history
				    if (count == this.x[i1]) {
                        // add the last result to the end
                        this.lastNewHistory.push(i1);
                        // while we have more history than we need, remove the first/oldest element
                        while (this.lastNewHistory.length > this.drop.preventConsecutiveDupes) {
                            this.lastNewHistory.shift();
                        }
				    }
				}

			} else {
				this.lastItem = null;
				this.lastItemCount = 0;
			}

			return ret;
		}

		otherSuccess(itemName, count) {
			var ret = false;
		    for (var d = 0; d < this.drop.items.length; d++) {
		        if (this.drop.items[d].name == itemName) {
		            this.otherx[d] += count;
		            // see if the total count has just now met or exceeded the required number
                    if (this.x[d] + this.otherx[d] - count < this.drop.items[d].required &&
                        this.x[d] + this.otherx[d] >= this.drop.items[d].required) {
                        // if the item has hit its required number, increment the number of successful items
                        this.numSuccess++;
                        // if the number of successful items has hit the drop's required number successes, then
                        // return success
                        if (this.numSuccess == this.requiredItems) {
    						ret = true;
                        }
                    }
		        }
		    }
			return ret;
		}
	}

	class Range {
	    constructor() {
	        this.min = 1;
	        this.max = 1;
	        this.increment = 1;
	        this.overflow = true;
	    }

	    generate(left) {
	        // if we've already overflowed then we have 0 left
	        if (left < 0) left = 0;
	        // if we're allowing overflows then use the stated max, otherwise take the min of the max and how many are left
	        var max = this.overflow ? this.max : Math.min(left, this.max)
	        if (this.min == max) {
	            // shortcut
	            return this.min;
	        }
	        if (max == 0) {
	            return 0;
            }

	        // Here's where more RNG happens

	        // pick a random integer between min and max, inclusive
	        return this.min +
	            // random number between 0 (inclusive) and 1 (exclusive)
	            Math.floor(Math.random() *
	                // multiply by the number of increments there are between min and max, inclusive
	                Math.floor((max - this.min)/this.increment + 1)
                ) * this.increment;
	    }

	    verify() {
	        var errors = Array();
	        if (this.min > this.max) {
	            errors.push("minimum is greater than maximum");
	        }
	        if (this.max <= 0) {
	            errors.push("must be greater than zero");
	        }
	        if (this.min < 0) {
	            errors.push("minimum must be zero or greater");
	        }
	        if (this.increment <= 0) {
	            errors.push("increment must be greater than zero");
	        }
	        return errors;
	    }

	    toString() {
	        if (this.min == this.max && this.overflow) {
	            return this.min.toFixed(0);
	        }
	        if (this.increment == 1 && this.overflow) {
    	        return this.min.toFixed(0) + "-" + this.max.toFixed(0);
    	    }
            return this.min.toFixed(0) + "-" + this.max.toFixed(0) + "," + this.increment.toFixed(0) + "," + (this.overflow ? "o" : "u");
	    }

	    fromString(s) {
            var regex = /(\d+)(?:-(\d+)(?:,(\d+)(?:,([ou]))?)?)?/g;
            var match = regex.exec(s);
            if (!match) {
                throw "Invalid format: \"" + s + "\"";
            }

            this.min = readInt(match[1]);

            if (match[2]) {
	            this.max = readInt(match[2]);

	            if (match[3]) {
    	            this.increment = readInt(match[3]);

                    if (match[4]) {
                        this.overflow = "o" == match[4];

                    } else {
                        this.overflow = true;
                    }
	            } else {
	                this.increment = 1;
                    this.overflow = true;
	            }

	        } else {
                this.max = this.min;
                this.increment = 1;
                this.overflow = true;
	        }

	        return this;
	    }
	}

    // data model for generating and tracking the results from running a single mission
	class MissionRunner {
	    constructor(mission) {
            this.mission = mission;
            // a list of drop runners for each of the mission's drops
            this.dropRunners = new Array(this.mission.drops.length);
            for (var i = 0; i < this.mission.drops.length; i++) {
                this.dropRunners[i] = new DropRunner(this.mission.drops[i]);
            }

            // see whether there is any time data to track
            this.hasTime = this.mission.hasTime();

            // if the mission's requred drop events is zero then all drop events are required
            this.requiredDrops = this.mission.requiredDrops > 0 ? this.mission.requiredDrops : this.dropRunners.length;

            // track total number of missions and total mission time
            this.totalMissions = 0;
            this.totalMissionTime = 0;

            // TrialData objects for holding the run and time results
            this.totalResults = new TrialData();
            this.totalTimeResults = !this.hasTime ? null : new TrialData();
        }

		verify() {
		    var errors = Array();
		    if (this.dropRunners.length == 0) {
		        errors.push("contains no drops");
		    }
		    for (var r = 0; r < this.dropRunners.length; r++) {
		        var dropRunner = this.dropRunners[r];
		        var dropErrors = dropRunner.verify();
		        for (var error in dropErrors) {
		            errors.push(dropRunner.drop.name + " -> " + dropErrors[error]);
		        }
		    }
		    if (this.requiredDrops > this.dropRunners.length) {
		        errors.push("required drops is greater than the number of drops");
		    }
		    return errors;
		}

		reset() {
	        // reset everything
            for (var i = 0; i < this.dropRunners.length; i++) {
				this.dropRunners[i].reset();
			}
			this.totalMissions = 0;
			this.totalMissionTime = 0;
		}

		run(scenaroRunner) {
			var numGot = 0;
            for (var r = 0; r < this.dropRunners.length; r++) {
                var dropRunner = this.dropRunners[r];
                if (dropRunner.hasSucceeded()) {
                    numGot++;
                }
            }

			// this tracks the number of drops we actually need to run.  If mission.bailEarly is set then
			// we will reduce this if the later drops succeed before the earlier ones.
			var maxDrops = this.mission.getNumDrops();

            // loop until the number of successful drops matches our required number of successful drops
			for (; numGot < this.requiredDrops; this.totalMissions++) {
			    // append the base mission time
				this.totalMissionTime += this.mission.time;
				// drop number is tracked separate from drop index, because some drops can repeat
				// multiple times
				var dropNum = 0;

                // loop over the drops
                for (var r = 0; r < this.dropRunners.length; r++) {
                    var dropRunner = this.dropRunners[r];
                    // loop over all the repetitions of the drop
					for (var i = 0; i < dropRunner.drop.dropsPerMission; i++) {
						dropNum++;
						// break early if we're past the max number of drops we need
						if (dropNum > maxDrops) {
							break;
						}

                        // append the drop time
						this.totalMissionTime += dropRunner.drop.time;

						// run the drop once, and see if it was successful
						var success = dropRunner.run()

						if (success) {
						    // drop was just now successful, so increment the number of successful drops
							numGot++;
						}

						if (dropRunner.lastItem) {
						    // if the event had a successful item drop then we need to cross reference that item's name
						    // with the other drops.
						    var otherNumGot = this.otherSuccess(dropRunner, dropRunner.lastItem.name, dropRunner.lastItemCount);
						    if (otherNumGot > 0) {
                                numGot += otherNumGot;
                                success = true;
                            }

                            // we also need to cross reference with later missions in the scenario
                            scenaroRunner.otherSuccess(this, dropRunner.lastItem.name, dropRunner.lastItemCount);
						}

                        // if there was a item that made any drop successful and early bailing is enabled, then
                        // we need to recalcaulate where we can bail early
						if (success && this.mission.bailEarly) {
                            // start with the total drops in the mission
                            maxDrops = this.mission.getNumDrops();
                            // loop backwards from the last drop to the first
                            for (var r2 = this.dropRunners.length - 1; r2 >= 0; r2--) {
                                var rot = this.dropRunners[r2];
                                if (rot.hasSucceeded()) {
                                    // if this drop has succeeded then decrement the maximum number of
                                    // drops we need to run
                                    maxDrops -= rot.drop.dropsPerMission;

                                } else {
                                    // otherwise, we've hit a drop that is still waiting for success, so break
                                    // the loop and leave maxDrops where it is.
                                    break;
                                }
                            }
						}
					}
				}
			}

			// we did it!

            // add the total number of mission runs to our results
			this.totalResults.addResult(this.totalMissions, this);
            // add the total amount of time to our time results, if applicable
			if (this.totalTimeResults !== null) {
				this.totalTimeResults.addResult(this.totalMissionTime, this);
			}
		}

		otherSuccess(dropRunner, lastItemName, lastItemCount) {
    		var numGot = 0;
            for (var r2 = 0; r2 < this.dropRunners.length; r2++) {
                var dropRunner2 = this.dropRunners[r2];
                if (dropRunner2 !== dropRunner && dropRunner2.otherSuccess(lastItemName, lastItemCount)) {
                    // the item made another drop successful, so increment the number of successful drops
                    numGot++;
                }
            }
            return numGot;
		}

        collectItems(itemSet) {
            for (var r = 0; r < this.dropRunners.length; r++) {
                var dropRunner = this.dropRunners[r];
                for (var d = 0; d < dropRunner.drop.items.length; d++) {
                    var name = dropRunner.drop.items[d].name;
                    var count = dropRunner.x[d];
                    if (!itemSet[name]) {
                        itemSet[name] = count;
                    } else {
                        itemSet[name] += count;
                    }
                }
            }
        }

   		customResults() {
   		    // nothing else to display
   		    return null;
   		}

        /* Currently not that useful outside of debugging Riven rolls
   		customResultUI() {
   		    // nothing else to display
   		    return null;
   		}

   		clearCustomResultUI() {
   		    // nothing else to display
   		    return null;
   		}
   		*/

		toString() {
            // produce a desciptive string of this mission's results.

            var itemSet = new Array();
            this.collectItems(itemSet);

            var s2 = "";
            for (var name in itemSet) {
                if (s2.length > 0) {
                    s2 += ", ";
                }
                s2 += name + ": " + itemSet[name];
            }

            return this.mission.name + ": " + this.totalMissions + "<br/>" + s2;
		}
	}

    // data model for generating and tracking the results from running a list of missions
	class ScenarioRunner {
	    constructor(scenario) {
            this.scenario = scenario;
            // create a mission runner for each of our missions
            this.missionRunners = new Array(this.scenario.missions.length);
            for (var i = 0; i < this.scenario.missions.length; i++) {
                var mission = this.scenario.missions[i];
                if (mission instanceof Mission) {
                    // This covers Mission Scenarios and Enemy Scenarios
                    this.missionRunners[i] = new MissionRunner(mission);

                } else if (mission instanceof RivenRoll) {
                    this.missionRunners[i] = new RivenRollRunner(mission);
                }
            }
            // see whether there is any time data to track
            this.hasTime = this.scenario.hasTime();

            // if there is only one mission then just use its results as our own
            if (this.missionRunners.length == 1) {
                this.totalResults = this.missionRunners[0].totalResults;
                this.totalTimeResults = this.missionRunners[0].totalTimeResults;

            } else {
                // otherwise, we need our own results to aggregate the results from all the missions.
                this.totalResults = new TrialData();
                this.totalTimeResults = !this.hasTime ? null : new TrialData();
            }

            // track total number of missions and total mission time from all missions
            this.totalMissions = 0;
            this.totalMissionTime = 0;
        }

		verify() {
		    var errors = Array();
		    if (this.missionRunners.length == 0) {
		        errors.push("scenario is empty");
		    }
		    for (var r = 0; r < this.missionRunners.length; r++) {
		        var missionRunner = this.missionRunners[r];
		        var missionErrors = missionRunner.verify();
		        for (var error in missionErrors) {
		            errors.push(missionRunner.mission.name + " -> " + missionErrors[error]);
		        }
		    }
		    return errors;
		}

		run() {
		    // this represents a full trial with a list of missions:  Starting from zero, running each mission
		    // in turn until it is successful, and moving on to the next mission until there're all done.

		    // reset
            for (var i = 0; i < this.missionRunners.length; i++) {
                this.missionRunners[i].reset();
            }
			this.totalMissions = 0;
			this.totalMissionTime = 0;


            for (var i = 0; i < this.missionRunners.length; i++) {
                var missionRunner = this.missionRunners[i];
                // run each mission to completion
				missionRunner.run(this);
				// add up the total number of runs and total time from each mission
				this.totalMissions += missionRunner.totalMissions;
				this.totalMissionTime += missionRunner.totalMissionTime;
			}

            // if we have our own separate results, then add our total scenario result to them
			if (this.missionRunners.length != 1) {
				this.totalResults.addResult(this.totalMissions, this);
				if (this.totalTimeResults != null) {
					this.totalTimeResults.addResult(this.totalMissionTime, this);
				}
			}
		}

		otherSuccess(lastMissionRunner, lastItemName) {
            for (var i = 0; i < this.missionRunners.length; i++) {
                var missionRunner = this.missionRunners[i];
                if (lastMissionRunner != missionRunner) {
                    missionRunner.otherSuccess(null, lastItemName);
                }
            }
		}

		customResults() {
		    // assemble any custom results from our mission runners
		    var results = Array();
		    for (var m = 0; m < this.missionRunners.length; m++) {
		        var mResults = this.missionRunners[m].customResults();
		        if (mResults != null) {
                    for (var i = 0; i < mResults.length; i++) {
                        results.push(mResults[i]);
                    }
                }
		    }
		    return results.length == 0 ? null : results;
		}

		toString() {
            // produce a desciptive string of this missions list's results.

		    var s = "";

            var itemSet = new Array();
            for (var m = 0; m < this.missionRunners.length; m++) {
                var missionRunner = this.missionRunners[m];
                if (m > 0) {
                    s += ", ";
                }
                s += missionRunner.mission.name + ": " + missionRunner.totalMissions;

                missionRunner.collectItems(itemSet);
            }

            var s2 = "";
            for (var name in itemSet) {
                if (s2.length > 0) {
                    s2 += ", ";
                }
                s2 += name + ": " + itemSet[name];
            }

            return s + "<br/>" + s2;
		}
	}

	function toCumulativeProbs(items) {
	    // add up the probabilities in a list of items to produce a list of cumulative probabilities
		var cProbs = new Array(items.length);
		cProbs[0] = items[0].prob;
		for (var i = 1; i < items.length; i++) {
    	    cProbs[i] = cProbs[i - 1] + (items[i].prob ? items[i].prob : 0);
		}
		return cProbs;
	}

    //==============================================================
    // Riven Runner
    //==============================================================

    var rivenRollHistorySize = 5;

    class CriterionRunner {
        constructor(criterion) {
            this.criterion = criterion;
            this.clearResults();
            this.clearRun();
        }

        clearRun() {
            this.matchCount = 0;
        }

        clearResults() {
            this.acceptCount = 0;

            /* Currently not that useful outside of debugging Riven rolls
            this.acceptedPositiveStats = Array();
            this.acceptedNegativeStats = Array();
            for (var i = 0; i < rivenStatList.length; i++) {
                this.acceptedPositiveStats.push(0);
                this.acceptedNegativeStats.push(0);
            }
            */
        }

        verify(type) {
            return this.criterion.verify(type);
        }

        accept(positiveStats, negativeStats) {
            if (this.criterion.accept(positiveStats, negativeStats)) {
                this.matchCount++;
                if (this.matchCount < this.criterion.repeats) {
                    return false;
                }

                this.acceptCount++;
                /* Currently not that useful outside of debugging Riven rolls
                for (var i = 0; i < positiveStats.length; i++) {
                    this.acceptedPositiveStats[positiveStats[i]]++;
                }
                for (var i = 0; i < negativeStats.length; i++) {
                    this.acceptedNegativeStats[negativeStats[i]]++;
                }
                */
                return true;

            } else {
                return false;
            }
        }
    }

    // runner for actually generating Rivens and checking against the criteria
	class RivenRollRunner {
	    constructor(rivenRoll) {
            this.rivenRoll = rivenRoll;
            // conforming to MissionRunner interface
            this.mission = rivenRoll;

            this.criterionRunners = Array();
            for (var c = 0; c < this.rivenRoll.criteria.length; c++) {
                this.criterionRunners.push(new CriterionRunner(this.rivenRoll.criteria[c]));
            }
            // assume all Criteria have the same locked stats
            this.rivenRoll.criteria[0].updatePriorities();
            this.lockedPositives = this.rivenRoll.criteria[0].lockedPositives;
            this.lockedNegatives = this.rivenRoll.criteria[0].lockedNegatives;

            // track total number of missions and total mission time
            this.totalMissions = 0;

            // TrialData objects for holding the run and time results
            this.totalResults = new TrialData();

            // Store the last N rolls
            this.history = Array();
        }

		verify() {
		    var errors = Array();
		    // whoops no criteria
		    if (this.rivenRoll.criteria.length == 0) {
		        errors.push("contains no criteria");
		    }
		    // whoops invalid riven type
		    if (this.rivenRoll.type != "m" && this.rivenRoll.type != "g") {
		        errors.push("invalid riven type");
		    }
		    // verify each criterion
		    for (var c = 0; c < this.criterionRunners.length; c++) {
		        var criterionErrors = this.criterionRunners[c].verify(this.rivenRoll.type);
		        for (var error in criterionErrors) {
		            errors.push(this.criterionRunners[c].criterion.name + " -> " + criterionErrors[error]);
		        }
		    }
		    if (this.criterionRunners.length > 1) {
		        var locked = this.criterionRunners[0].criterion.lockedPositives;
    		    for (var c = 1; c < this.criterionRunners.length; c++) {
    		        var locked2 = this.criterionRunners[c].criterion.lockedPositives;
    		        if (intersection(locked, locked2).length != locked.length) {
    		            errors.push(this.criterionRunners[c].criterion.name + " -> locked positive stats do not match");
    		        }
		        }
		        var locked = this.criterionRunners[0].criterion.lockedNegatives;
    		    for (var c = 1; c < this.criterionRunners.length; c++) {
    		        var locked2 = this.criterionRunners[c].criterion.lockedNegatives;
    		        if (intersection(locked, locked2).length != locked.length) {
    		            errors.push(this.criterionRunners[c].criterion.name + " -> locked negative stats do not match");
    		        }
		        }
		    }
		    return errors;
		}

		reset() {
	        // reset almost everything
			this.totalMissions = 0;
			this.totalMissionTime = 0;
			// leave criteriaRunner results alone; they're cumulative over the whole run
		}

        generateStats(numStatProbs, stats, usedStats, pn, locked) {
            // generate a random percentage between 0 and 100.
            var d = Math.random() * 100.0;
            // search the cumulative probability list for how many stats are generated
            var num = binarySearch(numStatProbs, d);
            // convert the "not found" result to an index
            if (num < 0) {
                num = -(num + 1);
            }

            // use the first criterion in the list to determine things like which stats are applicable.
            var criterion = this.rivenRoll.criteria[0];
            // get the total number of applicable stats with the given "p" or "n" flag.
            var total = criterion.getNumApplicableStats(pn);
            for (var i = 0; i < usedStats.length; i++) {
                if (statHasFlag(usedStats[i], pn)) {
                    total --;
                }
            }
            for (var i = stats.length; i < num; i++) {
                // the actual number of stats we have to choose from is the total minus what's already been chosen
                // generate a random integer between zero inclusive and the number of available stats exclusive.
                var n = Math.floor(Math.random() * (total - i));
                // translate that count to an actual identifying stat index
                var stat = criterion.getApplicableStat(n, usedStats, pn);
                // add it to our stat list
                stats.push(stat);
                // add it to our total used stats list
                usedStats.push(stat);
            }

            return stats;
        }

		run(scenaroRunner) {
            // loop until we get a roll that passes one of the criteria
            var success = false;

            for (var c = 0; c < this.criterionRunners.length; c++) {
                var criterionRunner = this.criterionRunners[c];
                criterionRunner.clearRun();
            }

			for (; !success; this.totalMissions++) {
                var usedStats = new Array();
                // save the generated stats on the object for later used by toString()
                this.positiveStats = Array();
                this.negativeStats = Array();

                if (this.lockedPositives.length > 0) {
                    for (var i = 0; i < this.lockedPositives.length; i++) {
                        this.positiveStats.push(this.lockedPositives[i]);
                        usedStats.push(this.lockedPositives[i]);
                    }
                }

                if (this.lockedNegatives.length > 0) {
                    for (var i = 0; i < this.lockedNegatives.length; i++) {
                        this.negativeStats.push(this.lockedNegatives[i]);
                        usedStats.push(this.lockedNegatives[i]);
                    }
                }

                this.generateStats(rivenPositiveNumProbs, this.positiveStats, usedStats, "p", this.lockedPositives);
                this.generateStats(rivenNegativeNumProbs, this.negativeStats, usedStats, "n", this.lockedNegatives);

                // loop over the criteria
                for (var c = 0; c < this.criterionRunners.length; c++) {
                    var criterionRunner = this.criterionRunners[c];
                    // check if the roll is acceptable
                    if (criterionRunner.accept(this.positiveStats, this.negativeStats)) {
                        // this trial is done
                        success = true;
					}
				}
			}

			// we did it!

			// save history
            if (this.history.length < rivenRollHistorySize) {
                // okay, so it isn't *technically* the last N results, it's the first N results since the last
                // customResults() call.
                this.history.push([this.totalMissions, this.positiveStats, this.negativeStats]);
            }

            // add the total number of mission runs to our results
			this.totalResults.addResult(this.totalMissions, this);
		}

		otherSuccess(dropRunner, lastItemName) {
            // conforming to MissionRunner interface
		    // ignore
		}

        collectItems(itemSet) {
            // conforming to MissionRunner interface
		    // ignore
        }

		customResults() {
            var results = Array();

            // we have custom results if there is a history
            if (this.history.length > 0) {
                if (this.history.length < rivenRollHistorySize && this.lastHistory) {
                    for (var i = 0, j = Math.min(this.lastHistory.length, rivenRollHistorySize - this.history.length); i < j; i++) {
                        this.history.push(this.lastHistory[i]);
                    }
                }
                var s = "";
                for (var i = 0; i < this.history.length; i++) {
                    if (i > 0) {
                        // make it readable
                        s += "<br/>\n";
                    }
                    s += "(" + this.history[i][0] + " rolls) " + this.toStringStats(this.history[i][1], this.history[i][2]);
                }
                // save the last history, in case the next block runs fewer than 5 trials
                this.lastHistory = this.history;
                // clear it out
                this.history = Array();

                results.push(["Last " + rivenRollHistorySize + " trials", s]);
            }

		    // we have more custom results if there is more than one criterion
		    if (this.criterionRunners.length > 1) {
                // build a list of criteria and what percentage of trials resulted in a match for each criterion
                var s = "";
                for (var i = 0; i < this.criterionRunners.length; i++) {
                    if (i > 0) {
                        // make it readable
                        s += "<br/>\n";
                    }
                    s += this.criterionRunners[i].criterion.name + ": " + ((this.criterionRunners[i].acceptCount / this.totalResults.numTrials) * 100).toFixed(0) + "%";
                }

                results.push(["Criteria met", s]);
            }

            this.totalResults.reCalc()
            results.push(["Riven Probability", (100.0 / this.totalResults.average).toFixed(4) + "%"]);

		    return results;
		}

        /* Currently not that useful outside of debugging Riven rolls
		customResultUI() {
            for (var c = 0; c < this.criterionRunners.length; c++) {
                var criterionRunner = this.criterionRunners[c];
                updateRivenCriterionResult(criterionRunner.criterion.resultElement, criterionRunner.acceptCount, criterionRunner.acceptedPositiveStats, criterionRunner.acceptedNegativeStats);
            }
		}

		clearCustomResultUI() {
            for (var c = 0; c < this.criterionRunners.length; c++) {
                var criterionRunner = this.criterionRunners[c];
                criterionRunner.clearResults()
                criterionRunner.criterion.resultElement.innerHTML = "";
            }
		}
		*/

		toString() {
            // produce a desciptive string of this riven roll's results.
            return this.toStringStats(this.positiveStats, this.negativeStats);
		}

		toStringStats(positiveStats, negativeStats) {
            var s = "";
            for (var i = 0; i < positiveStats.length; i++) {
                if (i > 0) {
                    s += ", ";
                }
                s += (statHasFlag(positiveStats[i], "r") ? "-" : "+") + getStatName(positiveStats[i]);
            }
            for (var i = 0; i < negativeStats.length; i++) {
                s += ", " + (statHasFlag(negativeStats[i], "r") ? "+" : "-") + getStatName(negativeStats[i]);
            }
            return s;
   		}
	}

    //==============================================================
    // Utility DOM functions
    // probably doing some of these the hard way but nothing else
    // was reliable enough
    // Most UI elements are identified by class instead of ID
    // because they're added dynamically and there can be more than
    // one of them in the DOM
    //==============================================================

    function getParent(node, parentClass) {
        // walk up the DOM until we find a parent with the given class name or run out of parents
        while (node != null && parentClass != (node.className)) {
            node = node.parentNode;
        }
        return node;
    }

    function getFirstChild(node, childClass) {
        // perform a depth first search from the first child to the last,
        // until we find an element with the given class name
        var children = node.children;
        for (var i = 0; i < children.length; i++) {
            var child = node.children[i];
            if (child.className == childClass) {
                return child;
            }
            // recursive call
            var child2 = getFirstChild(child, childClass);
            if (child2 !== null) {
                return child2;
            }
        }
        return null;
    }

    function getLastChild(node, childClass) {
        // perform a depth first search going from the last child to the first,
        // until we find an element with the given class name
        var children = node.children;
        // go over the children in reverse order
        for (var i = children.length - 1; i >= 0; i--) {
            var child = node.children[i];
            if (child.className == childClass) {
                return child;
            }
            // recursive call
            var child2 = getLastChild(child, childClass);
            if (child2 !== null) {
                return child2;
            }
        }
        return null;
    }

    function getAllChildren(node, childClass) {
        // find all the children with the given class name
        return getAllChildren0(node, childClass, Array());
    }

    function getAllChildren0(node, childClass, list) {
        var children = node.children;
        for (var i = 0; i < children.length; i++) {
            var child = node.children[i];
            if (child.className == childClass) {
                list.push(child);
            }
            getAllChildren0(child, childClass, list);
        }
        return list;
    }

    function deleteNode(node) {
        // delete an element from its parent
        node.parentNode.removeChild(node);
    }

    //==============================================================
    // UI Builders
    //==============================================================

    // track how many of each kind of scenario component we have
    var numMissions = 0;
    var numEnemies = 0;
    var numRivenRolls = 0;

    function updateAddMissionRivenButtons() {
        // We don't *have* to restrict scenarios to only contain one kind of mission/enemy/Riven Roll, but we will in
        // order to make things less confusing.
        // "Add Mission" is disabled if there are any Enemies or Riven Rolls.  It's still enabled if there is already a
        // Mission so that multiple missions can be added
        document.getElementById("addMission").disabled = (numRivenRolls > 0) || (numEnemies > 0) ;
        // "Add Enemy" is disabled if anything has been added
        document.getElementById("addEnemy").disabled = (numMissions > 0) || (numEnemies > 0) || (numRivenRolls > 0);
        // "Add Riven Roll" is disabled if anything has been added
        // Oh, let's enable multiple Riven Rolls if locked stats are enabled, because it's the only way to actually
        // simulate a full locked stats progression
        document.getElementById("addRivenRoll").disabled = (numMissions > 0) || (numEnemies > 0) || (!lockedEnabled && numRivenRolls > 0);
    }

    function getScenario() {
        return document.getElementById('scenario');
    }

    function clearScenario() {
        // clear the mission config and results

        // Stop any run in progress.
        stopRun();

        var missionTable = getFirstChild(getScenario(), "missionTable");
        var children = getAllChildren(missionTable, "missionRow");
        // delete all missions except for the placeholder "add" one
        for (var i = 0; i < children.length; i++) {
            deleteNode(children[i]);
        }

        // clear scenario name field
	    getFirstChild(document.getElementById("scenario"), "inputName").value = "";

        // clear the results
        clearResults()

        // reset scenario component counts
        numMissions = 0;
        numEnemies = 0;
        numRivenRolls = 0;
        // update button states
        updateAddMissionRivenButtons();
    }

    function addMission(scenarioNode, autoPop) {
        // static HTML for each mission config
        var html = `
        <tr class="missionRow">
            <td class="mission">
                <div class="modelTitle">Mission</div>
                <span class="tooltip">
                    <input class="button delete" type="submit" value="Delete" onclick="deleteMission(getParent(this, 'missionRow'))"/>
                    <span class="tooltiptext">Remove this mission from the list.</span>
                </span>
                <table class="fieldTable">
                    <tr>
                        <td class="tooltip">
                            Name:
                            <span class="tooltiptextbottom">The name of this mission</span>
                        </td>
                        <td>
                            <input class="inputName" type="text" value="Mission"/>
                        </td>
                    </tr>
                    <tr>
                        <td class="tooltip">
                            Mission Time:
                            <span class="tooltiptextbottom">The minimum amount of time in minutes that this mission takes, or '0' if the mission time is unknown or it's if completely determined by the drop events</span>
                        </td>
                        <td>
                            <input class="inputTime" type="number" value="0"/>
                        </td>
                    </tr>
                    <tr>
                        <td class="tooltip">
                            Drops Events Required:
                            <span class="tooltiptextbottom">The number of drop events that must successfully get all of their required items during the course of the run before this mission's is successful, or '0' if all of them are required.</span>
                        </td>
                        <td>
                            <input class="inputRequired" type="number" value="0"/>
                        </td>
                    </tr>
                    <tr>
                        <td class="tooltip">
                            Bail Early:
                            <span class="tooltiptextbottom">If enabled then a mission can be ended early if all the drop events after a certain point have already been successful earlier in the run.</span>
                        </td>
                        <td>
                            <input class="inputBailEarly" type="checkbox" checked/>
                        </td>
                    </tr>
                </table>
                <div class="add">
                    <span class="tooltip">
                        <input class="button addButton" type="submit" value="Add Drop Event" onclick="addDrop(getParent(this, 'missionRow'), true)"/>
                        <span class="tooltiptext">Add a drop event to the above mission.  Drop events are run in the order in which they are listed.</span>
                    </span>
                </div>
            </td>
            <td class="missionResults">
                <div class="trialResult"></div>
                <div class="timeResult"></div>
            </td>
        </tr>
        `;

        // find the "add" row under the scenario
        addNode = getLastChild(scenarioNode, "add");

        // insert the mission HTML before the "add" row
        addNode.insertAdjacentHTML("beforebegin", html);

        // find the "missionRow" element we just added
        newNode = addNode.previousElementSibling

        // if someone clicked the "add mission" button then go ahead and add a drop.
        if (autoPop) {
            addDrop(newNode, true);
        }

        // update button states
        numMissions++;
        updateAddMissionRivenButtons();

        // return the mission row element we just added
        return newNode;
    }

    function deleteMission(missionNode) {
        // delete the DOM element
        deleteNode(missionNode);
        // update button states
        numMissions--;
        updateAddMissionRivenButtons();
    }

    function addDrop(missionNode, autoPop) {
        // static HTML for each drop config
        var html = `
                <div class="drop">
                    <div class="modelTitle">Drop Event</div>
                    <span class="tooltip">
                        <input class="button delete" type="submit" value="Delete" onclick="deleteNode(getParent(this, 'drop'))"/>
                        <span class="tooltiptext">Remove this drop event.</span>
                    </span>
                    <table class="fieldTable">
                        <tr>
                            <td class="tooltip">
                                Name:
                                <span class="tooltiptextbottom">The name of this drop event.</span>
                            </td>
                            <td>
                                <input class="inputName" type="text" value="Drop"/>
                            </td>
                        </tr>
                        <tr>
                            <td class="tooltip">
                                Events Per Mission:
                                <span class="tooltiptextbottom">The number of times this drop event repeats in one mission, or '1' if it does not repeat.</span>
                            </td>
                            <td>
                                <input class="inputCount" type="number" value="1"/>
                            </td>
                        </tr>
                        <tr>
                            <td class="tooltip">
                                Event Time:
                                <span class="tooltiptextbottom">The amount of time it takes to get one drop event, in minutes, or '0' if the time is unknown or completely determined by the mission time.</span>
                            </td>
                            <td>
                                <input class="inputTime" type="number" value="0"/>
                            </td>
                        </tr>
                        <tr>
                            <td class="tooltip">
                                Items Required:
                                <span class="tooltiptextbottom">The number of items that must get their required number of drops during the course of a run, or '0' if all of them are required.</span>
                            </td>
                            <td>
                                <input class="inputRequired" type="number" value="0"/>
                            </td>
                        </tr>
                        <tr>
                            <td class="tooltip">
                                Prevent Consecutive Repeats:
                                <span class="tooltiptextbottom">If set to N greater than zero, then the drop will not return the last N items that dropped</span>
                            </td>
                            <td>
                                <input class="inputPreventDupes" type="number" value="0"/>
                            </td>
                        </tr>
                    </table>

                    <div class="add">
                        <span class="tooltip">
                            <input class="button addButton" type="submit" value="Add Item" onclick="addItem(getParent(this, 'drop'))"/>
                            <span class="tooltiptext">Add an item to the above drop.</span>
                        </span>
                    </div>

                </div>
        `;
        // find the "add" div under the mission
        addNode = getLastChild(missionNode, "add");

        // insert the drop HTML before the "add" div
        addNode.insertAdjacentHTML("beforebegin", html);

        // find the "drop" element we just added
        newNode = addNode.previousElementSibling

        // if someone clicked the "add drop" button then go ahead and add a item.
        if (autoPop) {
            addItem(newNode);
        }

        // return the drop element we just added
        return newNode;
    }

    function incrementName(name) {
        if (!name) {
            return null;
        }
        var results = new RegExp('(.*?)([0-9]+)').exec(name);
        if (!results) {
            return null;
        }
        return results[1] + (parseInt(results[2]) + 1);
    }

    function addItem(dropNode) {
        var name = null;
        var dropRate = null;

        var previousItemNode = getLastChild(dropNode, "item");
        if (previousItemNode) {
            name = incrementName(getLastChild(previousItemNode, "inputName").value);
            dropRate = getLastChild(previousItemNode, "inputRate").value
        }
        if (!name) {
            name = "Item1";
        }
        if (!dropRate) {
            dropRate = "10";
        }

        // static HTML for each item config
        var html = `
                    <div class="item">
                        <div class="modelTitle">Item</div>
                        <span class="tooltip">
                            <input class="button delete" type="submit" value="Delete" onclick="deleteNode(getParent(this, 'item'))"/>
                            <span class="tooltiptext">Remove this item.</span>
                        </span>
                        <table class="fieldTable">
                            <tr>
                                <td class="tooltip">
                                    Name:
                                    <span class="tooltiptextbottom">The name of the item.</span>
                                </td>
                                <td>
                                    <input class="inputName" type="text" value="${name}"/>
                                </td>
                            </tr>
                            <tr>
                                <td class="tooltip">
                                    Drop Rate:
                                    <span class="tooltiptextbottom">The drop rate of the item.  This is a percentage greater than 0% and less than 100%.</span>
                                </td>
                                <td>
                                    <input class="inputRate" type="number" value="${dropRate}" step="0.0001"/>%
                                </td>
                            </tr>
                            <tr>
                                <td class="tooltip">
                                    Drop Count:
                                    <span class="tooltiptextbottom">The number of items that drop at one time. This can be a single number, or a range like "6-30", or a range with an increment, like "6-30,2".</span>
                                </td>
                                <td>
                                    <input class="inputRange" type="text" value="1"/>
                                </td>
                            </tr>
                            <tr>
                                <td class="tooltip">
                                    Number Required:
                                    <span class="tooltiptextbottom">The number of times this item must drop during the course of a run to consider this item successful.</span>
                                </td>
                                <td>
                                    <input class="inputRequired" type="number" value="1"/>
                                </td>
                            </tr>
                        </table>
                    </div>
        `;
        // find the "add" div under the drop
        addNode = getLastChild(dropNode, "add");

        // insert the item HTML before the "add" div
        addNode.insertAdjacentHTML("beforebegin", html);

        // find the "item" element we just added
        newNode = addNode.previousElementSibling

        // return the item element we just added
        return newNode;
    }

    //==============================================================
    // Enemy UI builders
    //==============================================================

    function addEnemy(scenarioNode, autoPop) {
        // static HTML for each enemy config
        var html = `
        <tr class="missionRow">
            <td class="enemy">
                <div class="modelTitle">Enemy</div>
                <span class="tooltip">
                    <input class="button delete" type="submit" value="Delete" onclick="deleteEnemy(getParent(this, 'missionRow'))"/>
                    <span class="tooltiptext">Remove this enemy from the list.</span>
                </span>
                <table class="fieldTable">
                    <tr>
                        <td class="tooltip">
                            Name:
                            <span class="tooltiptextbottom">The name of the enemy</span>
                        </td>
                        <td>
                            <input class="inputName" type="text" value="enemy"/>
                        </td>
                    </tr>
                    <tr>
                        <td class="tooltip">
                            Items Required:
                            <span class="tooltiptextbottom">The number of items that must get their required number of drops during the course of a run, or '0' if all of them are required.</span>
                        </td>
                        <td>
                            <input class="inputRequired" type="number" value="0"/>
                        </td>
                    </tr>
                    <tr>
                        <td class="tooltip">
                            Prevent Consecutive Repeats:
                            <span class="tooltiptextbottom">If set to N greater than zero, then the drop will not return the last N items that dropped</span>
                        </td>
                        <td>
                            <input class="inputPreventDupes" type="number" value="0"/>
                        </td>
                    </tr>
                </table>
                <div class="add">
                    <span class="tooltip">
                        <input class="button addButton" type="submit" value="Add Item" onclick="addItem(getParent(this, 'missionRow'))"/>
                        <span class="tooltiptext">Add an item drop to the enemy.</span>
                    </span>
                </div>
            </td>

            <td class="missionResults">
                <div class="trialResult"></div>
                <div class="timeResult"></div>
            </td>
        </tr>
        `;

        // find the "add" row under the scenario
        addNode = getLastChild(scenarioNode, "add");

        // insert the mission HTML before the "add" row
        addNode.insertAdjacentHTML("beforebegin", html);

        // find the "missionRow" element we just added
        newNode = addNode.previousElementSibling

        // if someone clicked the "add enemy" button then go ahead and add an item.
        if (autoPop) {
            addItem(newNode);
        }

        // update button states
        numEnemies++;
        updateAddMissionRivenButtons();

        // return the mission row element we just added
        return newNode;
    }

    function deleteEnemy(enemyNode) {
        // delete the DOM element
        deleteNode(enemyNode);
        // update button states
        numEnemies--;
        updateAddMissionRivenButtons();
    }

    //==============================================================
    // Riven UI builders
    //==============================================================

    function addRivenRoll(scenarioNode, autoPop) {
        // static HTML for each riven roll config
        var html = `
        <tr class="missionRow">
            <td class="rivenRoll">
                <div class="modelTitle">Riven Roll</div>
                <span class="tooltip">
                    <input class="button delete" type="submit" value="Delete" onclick="deleteRivenRoll(getParent(this, 'missionRow'))"/>
                    <span class="tooltiptext">Remove this riven roll.</span>
                </span>
                <table class="fieldTable">
                    <!-- No need for name field because there can only be one of these
                    <tr>
                        <td class="tooltip">
                            Name:
                            <span class="tooltiptextbottom">A descriptive name for the Riven Roll</span>
                        </td>
                        <td>
                            <input class="inputName" type="text" value="Riven Roll"/>
                        </td>
                    </tr>
                    -->
                    <tr>
                        <td class="tooltip">
                            Riven Type:
                            <span class="tooltiptextbottom">Select the type of Riven.</span>
                        </td>
                        <td>
                            <select class="rivenTypeSelect" onchange="setRivenType(getParent(this, 'rivenRoll'), this.value)">
                                <option value="g" selected>Gun</option>
                                <option value="m">Melee</option>
                            </select>
                        </td>
                    </tr>
                </table>
                <div class="add">
                    <span class="tooltip">
                        <input class="button addButton" type="submit" value="Add Criteria" onclick="addRivenCriterion(getParent(this, 'rivenRoll'), true)"/>
                        <span class="tooltiptext">Add a criteria for a successful riven roll.</span>
                    </span>
                </div>
            </td>
            <td class="missionResults">
                <div class="trialResult"></div>
                <div class="timeResult"></div>
            </td>
        </tr>
        `;

        // find the "add" row under the scenario
        var addNode = getLastChild(scenarioNode, "add");

        // insert the riven roll HTML before the "add" row
        addNode.insertAdjacentHTML("beforebegin", html);

        // find the "missionRow" element we just added
        var newNode = addNode.previousElementSibling

        // go down a level to the "rivenRoll" div.
        var rivenNode = getFirstChild(newNode, "rivenRoll");

        // set the Riven type to Gun by default
        setRivenType(rivenNode, "g");

        // if someone clicked the "add riven roll" button then go ahead and add a criterion.
        if (autoPop) {
            addRivenCriterion(rivenNode, true);
        }

        // update button states
        numRivenRolls++;
        updateAddMissionRivenButtons();

        // return the riven roll row element we just added
        return rivenNode;
    }

    function deleteRivenRoll(rivenRollNode) {
        // delete the DOM element
        deleteNode(rivenRollNode);
        // update button states
        numRivenRolls--;
        updateAddMissionRivenButtons();
    }

    function setRivenType(rivenNode, type) {
        // make things easy, just save the type identifier directly on the DOM element
        rivenNode.type = type;
        // find all the criteria nodes
        var criteriaNodes = getAllChildren(rivenNode, "drop");
        for (var i = 0; i < criteriaNodes.length; i++) {
            // reset the riven type on each criterion
            setRivenCriterionType(criteriaNodes[i], type);
        }
    }

    function addRivenCriterion(rivenNode, autoPop, statPriority) {
        // static HTML for each riven criterion config
        var html = `
        <div class="drop">
            <table>
                <tr>
                    <td>
                        <div class="modelTitle">Riven Criteria</div>
                        <span class="tooltip">
                            <input class="button delete" type="submit" value="Delete" onclick="deleteNode(getParent(this, 'drop'))"/>
                            <span class="tooltiptext">Remove this riven criteria.</span>
                        </span>
                        <span class="tooltip">
                            <input class="button delete" type="submit" value="Reset" onclick="clearRivenCriterion(getParent(this, 'drop'))"/>
                            <span class="tooltiptext">Reset this riven criteria.</span>
                        </span>
                        <table class="fieldTable">
                            <tr>
                                <td class="tooltip">
                                    Name:
                                    <span class="tooltiptextbottom">A decriptive name for the riven criteria</span>
                                </td>
                                <td>
                                    <input class="inputName" type="text" value="Criteria"/>
                                </td>
                            </tr>
                            <tr>
                                <td class="tooltip">
                                    Required positives:
                                    <span class="tooltiptextbottom">The required number of positive stats.</span>
                                </td>
                                <td>
                                    <select class="inputRequired">
                                        <option value="-1">2 or 3</option>
                                        <option value="2">2</option>
                                        <option value="3">3</option>
                                    </select>
                                </td>
                            </tr>
                            <tr>
                                <td class="tooltip">
                                    Required negatives:
                                    <span class="tooltiptextbottom">The required number of negative stats.</span>
                                </td>
                                <td>
                                    <select class="inputRequired">
                                        <option value="-1">0 or 1</option>
                                        <option value="0">0</option>
                                        <option value="1">1</option>
                                    </select>
                                </td>
                            </tr>`;
        if (lockedEnabled) {
            html += `
                            <tr>
                                <td class="tooltip">
                                    Repeats:
                                    <span class="tooltiptextbottom">The number of times this criteria must be met.</span>
                                </td>
                                <td>
                                    <input class="inputCount" type="number" value="1"/>
                                </td>
                            </tr>`;
        }
        html += `
                            <tr>
                                <td class="tooltip">
                                    Stat priorities:
                                    <span class="tooltiptextbottom">
                                        This list below defines the acceptable stats:<br/>
                                            ++: Required positive stat<br/>
                                            +: Wanted positive stat<br/>
                                            ?: Don't Care<br/>
                                            -: Wanted negative stat
                                    </span>
                                </td>
                            </tr>
                        </table>
                        <table class="rivenFieldTable">
                        </table>
                    </td>
                    <td class="missionResults">
                        <div class="trialResult"></div>
                    </td>
                </tr>
            </table>
        </div>
        `;

        // find the "add" row under the riven roll
        var addNode = getLastChild(rivenNode, "add");

        // insert the riven criterion HTML before the "add" row
        addNode.insertAdjacentHTML("beforebegin", html);

        // find the "missionRow" element we just added
        var newNode = addNode.previousElementSibling

        if (autoPop || statPriority) {
            // if we're autopopulating, or we have a prefilled list of stat priorities, go ahead and build the stat list UI
            // pretty sure one of those will always be true...
            setRivenCriterionType(newNode, rivenNode.type, statPriority);
        }

        // return the riven criterion element we just added
        return newNode;
    }

    // We want a separate radio button group for each stat's set of priority buttons, regardless of how many Riven
    // Criteria are added or deleted.  The easy way is to just keep a global incrementing counter.
    var radioId = 0;

    function clearRivenCriterion(node) {
        // reset all the priority selections back to "don't care".

        // find all the individual "Don't care" synthetic checkboxes
        var checkmarks = getAllChildren(node, 'checkmark dontcare');
        for (var i = 0; i < checkmarks.length; i++) {
            // go up to the container and then find the actual checkbox input element
            var parent = getParent(checkmarks[i], 'container');
            var checkbox = getFirstChild(parent, 'radio');
            // check it
            checkbox.checked = "checked";
            // have to call this manually
            checkbox.onchange();
        }
    }

    function setRivenCriterionType(node, type, statPriority) {
        // find the stat priority table
        var tableNode = getFirstChild(node, "rivenFieldTable");

        // Just blow away all the current stat priorities and start over
        // todo: migrate in place rather than rebuilding from scratch
        tableNode.innerHTML = "";

        // get the applicable stats for the given Riven type
        var stats = getRivenStatGroup([type]);

        for (var i = 0; i < stats.length; i++) {
            var index = stats[i];
            // if we have a starting set of priorities then use that, otherwise initialize to "Don't Care".
            var priority = statPriority ? statPriority[index] : "d";
            // increment the global radio button group counter
            radioId++;

            var html = `
                    <tr class="rivenCriterionNode">
                        <td>
                            ${getStatName(index)}
                        </td>
                        <td>
                            <div class="statPriorityGroup">`;
            // if the stat is allowed for positive stats then show those checkboxes
            if (statHasFlag(index, "p")) {
                if (lockedEnabled) {
                    // hide this unless you open a scenario link containing locked stats
                    html += `
                                <label class="container">
                                    <input class="radio" type="radio" ${priority == "L" ? ' checked="checked"' : ""} name="radio${radioId}" onchange="setPriority(getParent(this, 'rivenCriterionNode'), 'L')">
                                    <span class="checkmark positiveLock">L</span>
                                </label>`;
                }
                html += `
                                <label class="container">
                                    <input class="radio" type="radio" ${priority == "P" ? ' checked="checked"' : ""} name="radio${radioId}" onchange="setPriority(getParent(this, 'rivenCriterionNode'), 'P')">
                                    <span class="checkmark positiveReq">++</span>
                                </label>
                                <label class="container">
                                    <input class="radio" type="radio" ${priority == "p" ? ' checked="checked"' : ""} name="radio${radioId}" onchange="setPriority(getParent(this, 'rivenCriterionNode'), 'p')">
                                    <span class="checkmark positive">+</span>
                                </label>`;
            }
            // always show the "Don't Care" checkbox
            html += `
                                <label class="container">
                                    <input class="radio" type="radio" ${priority == "d" ? ' checked="checked"' : ""} name="radio${radioId}" onchange="setPriority(getParent(this, 'rivenCriterionNode'), 'd')">
                                    <span class="checkmark dontcare">?</span>
                                </label>`;
            // if the stat is allowed for negative stats then show those checkboxes
            if (statHasFlag(index, "n")) {
                html += `
                                <label class="container">
                                    <input class="radio" type="radio" ${priority == "n" ? ' checked="checked"' : ""} name="radio${radioId}" onchange="setPriority(getParent(this, 'rivenCriterionNode'), 'n')">
                                    <span class="checkmark negative">-</span>
                                </label>
                                <!-- Required Negatives is pointless as long as you can only have one negative stat
                                <label class="container">
                                    <input class="radio" type="radio" ${priority == "N" ? ' checked="checked"' : ""} name="radio${radioId}" onchange="setPriority(getParent(this, 'rivenCriterionNode'), 'N')">
                                    <span class="checkmark negativeReq">--</span>
                                </label>
                                -->`
                if (lockedEnabled) {
                    // hide this unless you open a scenario link containing locked stats
                    html += `
                                <label class="container">
                                    <input class="radio" type="radio" ${priority == "l" ? ' checked="checked"' : ""} name="radio${radioId}" onchange="setPriority(getParent(this, 'rivenCriterionNode'), 'l')">
                                    <span class="checkmark negativeLock">L</span>
                                </label>`;
                }
            }

            html += `
                            </div>
                        </td>
                    </tr>
            `;
            //
            tableNode.insertAdjacentHTML("beforeend", html);
            newNode = getLastChild(tableNode, "rivenCriterionNode");
            // the easy way, just save properties to the DOM element for the identifying index and the currently
            // selected  priority
            newNode.index = index;
            newNode.priority = priority;
        }
    }

    function setPriority(rivenCriterionNode, priority) {
        // the easy way, just save a property to the DOM element
        rivenCriterionNode.priority = priority;
    }

    //==============================================================
    // misc UI
    //==============================================================

    function showErrors(errors) {
        // find the error bar
        var errorBarElement = document.getElementById("errorBar");
        // build and error div with a line for each error in the list
        var html = `<div id="error">`;
        for (var error in errors) {
            html += `<div class="errorLine">${errors[error]}</div>`;
        }
        html += `</div>`;
        // show
        errorBarElement.innerHTML = html;
    }

    function clearErrors() {
        // find the error bar and clear it out
        var errorBarElement = document.getElementById("errorBar");
        errorBarElement.innerHTML = "";
    }

    //==============================================================
    // Model-View control
    //==============================================================

    var showHelpUrlString = "&h=yes";
    var autoStartUrlString = "&start=start";

    function initModel() {
        // javascript is working
        clearErrors();

        var url = window.location.href;

        if (getQueryParam(url, "h")) {
            about();
        }

        // initialize the example selector
        var select = document.getElementById("samplesSelect");
        select.value = select.options.item(0).value;

        reinitModel(url);
    }

    function reinitModel(url) {
        // on page load, see if there's a "m=..." query string
        var modelString = getQueryParam(url, "m");
        // if there is, then initialize our config
        setModelString(modelString);

        // see if the stop number was also specified
        var stopAfterString = getQueryParam(url, "s");
        if (stopAfterString) {
            // parse and sanitize the stop number
            var stopAfter = readInt(stopAfterString);
            // update the UI
            if (stopAfter > 0) {
                document.getElementById("stopAfter").value = stopAfter;
            }
        }

        // see if the start param was specified in the URL
        var startString = getQueryParam(url, "start");
        if (startString) {
            // update the UI to match
            document.getElementById("copyUrlAutoStart").checked = true;
            // start the simulation automatically
            startRun();
        }
    }

    function setModelString(modelString) {
        if (modelString !== null && modelString.length > 0) {
            try {
                // parse a model from the string
                var scenarioModel = new Scenario().fromString(modelString);
                // build the UI
                setModel(scenarioModel);
                // clear any error
                clearErrors();

            } catch (error) {
                // show an error
                showErrors([error]);
            }
        }
    }

    function copyModelUrl() {
        // build a model from the UI
        var scenarioModel = getModel()

        // serialize the model to a String
        var string = scenarioModel.toString();

        // get the currently specified stop number
        var stopAfter = document.getElementById("stopAfter").value;
        // get whether autostart was enabled
        var autoStart = document.getElementById("copyUrlAutoStart").checked;
        // build a full URL using the current URL
        var url = buildQueryUrl(string, stopAfter, autoStart);

        // find the pop-up URL text field and set its contents
        var textField = document.getElementById("urlHolder");
        textField.value = url;
        // show the popup
        var popup = document.getElementById("popupBox");
        popup.classList.toggle("show");
        // focus and select the contents of the text field
        textField.focus();
        textField.select();
    }

    function hideUrlPopup() {
        // hide the popup when the text field loses focus
        var popup = document.getElementById("popupBox");
        popup.classList.toggle("show");
        // todo: the onBlur() event fails to get called sometimes in Chrome
    }

    function buildQueryUrl(paramValue, stopAfter, autoStart) {
        // get the current URL and strip out any query string
        var url = window.location.href;
        url = url.replace(/\?.*/, "");
        // append our parameters
        url += "?m=" + paramValue;
        url += "&s=" + stopAfter;
        if (autoStart) {
            url += autoStartUrlString;
        }
        return url;
    }

    function setModel(scenarioModel) {
        // build the UI corresponding to the given model

        // clear out any existig UI
        clearScenario();
        // get the root HTML element of the scenario
        var scenario = getScenario();
        // set the scenario name
        getFirstChild(scenario, "inputName").value = scenarioModel.name;

        // loop over the missions
        for (var m = 0; m < scenarioModel.missions.length; m++) {
            var model = scenarioModel.missions[m];
            if (model instanceof Enemy) {
                var enemyModel = model;

                // add a enemy UI to the list
                var enemy = addEnemy(scenario, false);
                // copy enemy config
                getFirstChild(enemy, "inputName").value = enemyModel.name;
                getFirstChild(enemy, "inputRequired").value = enemyModel.drops[0].requiredItems;
                getFirstChild(enemy, "inputPreventDupes").value = enemyModel.drops[0].preventConsecutiveDupesAppliesToNew ? -enemyModel.drops[0].preventConsecutiveDupes : enemyModel.drops[0].preventConsecutiveDupes;

                var dropModel = enemyModel.drops[0];
                var drop = enemy;

                // loop over the items in this drop
                for (var d = 0; d < dropModel.items.length; d++) {
                    var itemModel = dropModel.items[d];
                    // add a item UI to the drop
                    var item = addItem(drop, false);
                    // copy item config
                    getFirstChild(item, "inputName").value = itemModel.name;
                    getFirstChild(item, "inputRate").value = itemModel.prob;
                    getFirstChild(item, "inputRange").value = itemModel.range.toString();
                    getFirstChild(item, "inputRequired").value = itemModel.inARow ? -itemModel.required : itemModel.required;
                }

            } else if (model instanceof Mission) {
                var missionModel = model;

                // add a mission UI to the list
                var mission = addMission(scenario, false);
                // copy mission config
                getFirstChild(mission, "inputName").value = missionModel.name;
                getFirstChild(mission, "inputTime").value = missionModel.time;
                getFirstChild(mission, "inputRequired").value = missionModel.requiredDrops;
                getFirstChild(mission, "inputBailEarly").checked = missionModel.bailEarly;

                // loop over the drops in this mission
                for (var r = 0; r < missionModel.drops.length; r++) {
                    var dropModel = missionModel.drops[r];
                    // add a drop UI to the mission
                    var drop = addDrop(mission, false);
                    // copy drop config
                    getFirstChild(drop, "inputName").value = dropModel.name;
                    getFirstChild(drop, "inputCount").value = dropModel.dropsPerMission;
                    getFirstChild(drop, "inputTime").value = dropModel.time;
                    getFirstChild(drop, "inputRequired").value = dropModel.requiredItems;
                    getFirstChild(drop, "inputPreventDupes").value = dropModel.preventConsecutiveDupes;
                    getFirstChild(drop, "inputPreventDupes").value = dropModel.preventConsecutiveDupesAppliesToNew ? -dropModel.preventConsecutiveDupes : dropModel.preventConsecutiveDupes;

                    // loop over the items in this drop
                    for (var d = 0; d < dropModel.items.length; d++) {
                        var itemModel = dropModel.items[d];
                        // add a item UI to the drop
                        var item = addItem(drop, false);
                        // copy item config
                        getFirstChild(item, "inputName").value = itemModel.name;
                        getFirstChild(item, "inputRate").value = itemModel.prob;
                        getFirstChild(item, "inputRange").value = itemModel.range.toString();
                        getFirstChild(item, "inputRequired").value = itemModel.inARow ? -itemModel.required : itemModel.required;
                    }
                }

            } else if (model instanceof RivenRoll) {
                var rivenRollModel = model;

                // add a riven roll UI to the list
                var rivenRoll = addRivenRoll(scenario, false);
                // copy riven roll config
                // getFirstChild(rivenRoll, "inputName").value = rivenRollModel.name;
                getFirstChild(rivenRoll, "rivenTypeSelect").value = rivenRollModel.type;
                setRivenType(rivenRoll, rivenRollModel.type);

                // loop over the criteria in this riven roll
                for (var c = 0; c < rivenRollModel.criteria.length; c++) {
                    var criterionModel = rivenRollModel.criteria[c];
                    // add a criterion UI to the riven roll
                    // this will automatically select the criterion's stat priorities
                    var criterion = addRivenCriterion(rivenRoll, false, criterionModel.statPriority);
                    // copy other criterion config
                    getFirstChild(criterion, "inputName").value = criterionModel.name;
                    getFirstChild(criterion, "inputRequired").value = criterionModel.requiredNumPositives;
                    getLastChild(criterion, "inputRequired").value = criterionModel.requiredNumNegatives;
                    if (lockedEnabled) {
                        getLastChild(criterion, "inputCount").value = criterionModel.repeats;
                    }
                }
            }
        }
    }

    function getModel() {
        // build a model from the current state of the UI

        // get the scenario root element
        var scenario = getScenario();
        // create a new scenario model
        var scenarioModel = new Scenario()
        // copy the name
        scenarioModel.name = getFirstChild(scenario, "inputName").value;

        // add an extra property that stores the result element for the scenario
        scenarioModel.resultElement = document.getElementById("scenarioResults");

        // loop over all the mission elements under the scenario
        var missionRows = getAllChildren(scenario, "missionRow");
        for (var m = 0; m < missionRows.length; m++) {
            var missionRow = missionRows[m];

            // check for a Mission node
            var mission = getFirstChild(missionRow, "mission");
            if (mission) {
                // create a new mission model and add it to the scenario
                var missionModel = new Mission();
                scenarioModel.add(missionModel);
                // copy properties, sanitizing numeric inputs
                missionModel.name = getFirstChild(mission, "inputName").value;
                missionModel.time = readInt(getFirstChild(mission, "inputTime").value);
                missionModel.bailEarly = getFirstChild(mission, "inputBailEarly").checked;

                // add an extra property that stores the result element for the mission
                missionModel.resultElement = getFirstChild(getParent(mission, "missionRow"), "missionResults");

                // loop over all the drop elements under the mission
                var drops = getAllChildren(mission, "drop");
                for (var r = 0; r < drops.length; r++) {
                    var drop = drops[r];
                    // create a new drop model and add it to the mission
                    var dropModel = new Drop();
                    missionModel.add(dropModel);
                    // copy properties, sanitizing numeric inputs
                    dropModel.name = getFirstChild(drop, "inputName").value;
                    dropModel.dropsPerMission = readInt(getFirstChild(drop, "inputCount").value);
                    dropModel.time = readInt(getFirstChild(drop, "inputTime").value);
                    var ipd = readIntWithNegative(getFirstChild(drop, "inputPreventDupes").value)
                    dropModel.preventConsecutiveDupes = ipd < 0 ? -ipd : ipd;
                    dropModel.preventConsecutiveDupesAppliesToNew = ipd < 0;

                    // loop over all the item elements under the drop
                    var items = getAllChildren(drop, "item");
                    for (var d = 0; d < items.length; d++) {
                        var item = items[d];
                        // create a new item model and add it to the drop
                        var itemModel = new Item();
                        dropModel.add(itemModel);
                        // copy properties, sanitizing numeric inputs
                        itemModel.name = getFirstChild(item, "inputName").value;
                        itemModel.prob = readFloat(getFirstChild(item, "inputRate").value);
                        itemModel.range = new Range().fromString(getFirstChild(item, "inputRange").value);
                        itemModel.setRequired(readIntWithNegative(getFirstChild(item, "inputRequired").value));
                    }

                    // since add() can change this, set it last
                    dropModel.requiredItems = readInt(getFirstChild(drop, "inputRequired").value);
                }

                // since add() can change this, set it last
                missionModel.requiredDrops = readInt(getFirstChild(mission, "inputRequired").value);

            } else {
                // check for an Enemy node
                var enemy = getFirstChild(missionRow, "enemy");
                if (enemy) {
                    // create a new enemy model and add it to the scenario
                    var enemyModel = new Enemy();

                    scenarioModel.add(enemyModel);
                    // copy properties, sanitizing numeric inputs
                    enemyModel.name = getFirstChild(enemy, "inputName").value;

                    // add an extra property that stores the result element for the enemy
                    enemyModel.resultElement = getFirstChild(getParent(enemy, "missionRow"), "missionResults");

                    var drop = enemy;
                    var dropModel = enemyModel.drops[0];
                    dropModel.requiredItems = readInt(getFirstChild(drop, "inputRequired").value);
                    var ipd = readIntWithNegative(getFirstChild(drop, "inputPreventDupes").value)
                    dropModel.preventConsecutiveDupes = ipd < 0 ? -ipd : ipd;
                    dropModel.preventConsecutiveDupesAppliesToNew = ipd < 0;

                    // loop over all the item elements under the drop
                    var items = getAllChildren(drop, "item");
                    for (var d = 0; d < items.length; d++) {
                        var item = items[d];
                        // create a new item model and add it to the drop
                        var itemModel = new Item();
                        dropModel.add(itemModel);
                        // copy properties, sanitizing numeric inputs
                        itemModel.name = getFirstChild(item, "inputName").value;
                        itemModel.prob = readFloat(getFirstChild(item, "inputRate").value);
                        itemModel.range = new Range().fromString(getFirstChild(item, "inputRange").value);
                        itemModel.required = readInt(getFirstChild(item, "inputRequired").value);
                    }

                } else {
                    // check for a Riven Roll node
                    var rivenRoll = getFirstChild(missionRow, "rivenRoll");
                    if (rivenRoll) {
                        // create a new riven roll model and add it to the scenario
                        var rivenRollModel = new RivenRoll();
                        scenarioModel.add(rivenRollModel);
                        // copy properties, sanitizing numeric inputs
                        // rivenRollModel.name = getFirstChild(rivenRoll, "inputName").value;
                        rivenRollModel.type = rivenRoll.type;

                        // add an extra property that stores the result element for the rivenRoll
                        rivenRollModel.resultElement = getFirstChild(getParent(rivenRoll, "missionRow"), "missionResults");

                        // loop over all the criterion elements under the riven roll
                        var criteria = getAllChildren(rivenRoll, "drop");
                        for (var r = 0; r < criteria.length; r++) {
                            var criterion = criteria[r];

                            // create a new criterion  model and add it to the riven roll
                            var criterionModel = new RivenCriterion();
                            rivenRollModel.add(criterionModel);

                            // copy properties, sanitizing numeric inputs
                            criterionModel.name = getFirstChild(criterion, "inputName").value;
                            criterionModel.requiredNumPositives = readIntWithDefault(getFirstChild(criterion, "inputRequired").value, -1);
                            criterionModel.requiredNumNegatives = readIntWithDefault(getLastChild(criterion, "inputRequired").value, -1);
                            if (lockedEnabled) {
                                criterionModel.repeats = readIntWithDefault(getLastChild(criterion, "inputCount").value, 1);
                            }

                            // add an extra property that stores the result element for the criterion
                            criterionModel.resultElement = getFirstChild(criterion, "trialResult");

                            // loop over all the criterion elements
                            var criterionNodes = getAllChildren(criterion, "rivenCriterionNode");
                            for (var c = 0; c < criterionNodes.length; c++) {
                                var criterionNode = criterionNodes[c];
                                // pull the identifying stat index and priority from the DOM node properties
                                criterionModel.statPriority[criterionNode.index] = criterionNode.priority;
                            }
                        }
                    }
                }
            }
        }

        return scenarioModel;
    }

    function getQueryParam(url, name) {
        // from https://stackoverflow.com/questions/901115/how-can-i-get-query-string-values-in-javascript
        // weird that there's no built in function for this
        name = name.replace(/[\[\]]/g, '\\$&');
        var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)');
        var results = regex.exec(url);
        if (!results) {
            return null;
        }
        if (!results[2]) {
            return '';
        }
        return decodeURIComponent(results[2].replace(/\+/g, ' '));
    }

    //==============================================================
    // Result Viewer
    //==============================================================

    // percentiles to calculate and show
    var percentiles = [0.5, 0.9, 0.99];
    // smaller list for the histogram
    var percentilesForHistogram = [0.9, 0.99];

    function updateResult(resultElement, title, unitName, trialData, time, customResults) {
        // update a result element, either the run totals or time totals

        // if there's no data then clear the element
        if (!trialData || trialData === null) {
            resultElement.innerHTML = "";
            return;
        }

        // (re)calculate the trial data statistics
        trialData.reCalc();

        // this is basically just used to scale minutes to hours, if necessary
        var dataScale = 1.0;

        if (time) {
            // the cutoff between showing the results in minutes or hours is whether the average is more than 2 hours
            if (trialData.average > 120) {
                // scale to hours by dividing everything by 60
                unitName += " in Hours";
                dataScale /= 60;

            } else {
                // leave it in minutes
                unitName += " in Minutes";
            }
        }

        // make sure the result container is initialized
        addResultContainer(resultElement, title, unitName, trialData, dataScale, time);

        // update the statistics
        updateResultStatistics(resultElement, customResults);

        updateQuery(resultElement)

        // (re)draw the histogram
        updateHistogram(resultElement, );
    }

    function addResultContainer(resultElement, title, unitName, trialData, dataScale, time) {
        if (resultElement.children.length == 0) {
            // Building the base container HTML
            var html = `
                <table class="resultsTable"><tr>
                    <td>
                        <div class="about">
                            <div class="title">${title} - ${unitName}</div>
                            <div class="utilGroup">
                                <div class="util">
                                    <span class="tooltip">
                                        <input class="button densitySelected" type="submit" value="Probability Density" onClick="switchToDensity(this)"/>
                                        <span class="tooltiptextbottom">This shows the <a href="https://en.wikipedia.org/wiki/Probability_distribution">probability distribution</a>.</span>
                                    </span>
                                </div>
                                <div class="util">
                                    <span class="tooltip">
                                        <input class="button cumulative" type="submit" value="Cumulative Probability" onClick="switchToCumulative(this)"/>
                                        <span class="tooltiptextbottom">This shows the <a href="https://en.wikipedia.org/wiki/Cumulative_distribution_function">cumulative probability distribution</a>.</span>
                                    </span>
                                </div>
                            </div>
                        </div>
                        <div class="histogramContainer">
                        </div>`;
        // too much guesswork and estimates with Time to make queries useful
        if (!time) {
            html += `
                        <div class="histogramSettings">
                            <div class="util">
                                <span class="tooltip">
                                    <input class="button query" type="submit" value="Query" onClick="toggleQuery(this)"/>
                                    <span class="tooltiptextbottom">Query the data set.</span>
                                </span>
                            </div>
                            <table class="queryTable" style="display: none;">
                                <tr>
                                    <td class="statName">Result</td>
                                    <td class="statName">Percentile</td>
                                    <td class="statName">Odds</td>
                                </tr>
                                <tr class="queryRow">
                                    <td>
                                        <input class="inputResult" type="number" value="" step="1" onchange="calcPercentileFromResult(this)"/>
                                    </td>
                                    <td>
                                        <input class="inputPercentile" type="number" value="" step="0.01" onchange="calcResultFromPercentile(this)"/>%
                                    </td>
                                    <td>
                                        1 in <input class="inputOdds" type="number" value="" step="1" onchange="calcResultFromOdds(this)"/>
                                    </td>
                                </tr>
                            </table>
                        </div>`;
        }
        html += `
                    </td>
                    <!-- go ahead and set the width here to be similar to the canvas -->
                    <td width="550">
                        <span class="title">Statistics for ${title} - ${unitName}</span><br/>
                        <div class="statistics">
                        </div>
                    </td>
                </tr></table>
            `;

            // add the HTML
            resultElement.innerHTML = html;

            // save the relevant data to the DOM element so we can re-display the results without refreshing everything
            resultElement.title = title;
            resultElement.unitName = unitName;
            resultElement.trialData = trialData;
            resultElement.dataScale = dataScale;
        }
    }

    function calcPercentileFromResult(input) {
        setQuerySide(input, true);
        calcPercentile(input);
    }

    function calcResultFromPercentile(input) {
        var row = getParent(input, "queryRow");
        getFirstChild(row, "inputOdds").value = 100 / (100 - getFirstChild(row, "inputPercentile").value);
        setQuerySide(input, false);
        calcPercentile(input);
    }

    function calcResultFromOdds(input) {
        var row = getParent(input, "queryRow");
        getFirstChild(row, "inputPercentile").value = 100  * (1 - (1 / getFirstChild(row, "inputOdds").value));
        setQuerySide(input, false);
        calcPercentile(input);
    }

    function setQuerySide(input, lockResult) {
        var row = getParent(input, "queryRow");
        getFirstChild(row, "inputResult").lock = lockResult;
        getFirstChild(row, "inputPercentile").lock = !lockResult;
        getFirstChild(row, "inputOdds").lock = !lockResult;
    }

    function calcPercentile(input) {
        var row = getParent(input, "queryRow");
        var resultInput = getFirstChild(row, "inputResult");
        var percentileInput = getFirstChild(row, "inputPercentile");
        var oddsInput = getFirstChild(row, "inputOdds");

        var resultElement = getParent(input, "trialResult");
        if (!resultElement) {
            resultElement = getParent(input, "timeResult");
        }
        var trialData = resultElement.trialData;
        var dataScale = resultElement.dataScale;

        if (resultInput.lock && resultInput.value) {
            var percentile = trialData.resultToPercentile(resultInput.value) * 100;
            percentileInput.value = (percentile).toFixed(6);
            oddsInput.value = (100 / (100 - percentile)).toFixed(6);

        } else if (percentileInput.lock && percentileInput.value) {
            resultInput.value = trialData.percentileToResult(percentileInput.value / 100.0).toFixed(2);
        }
    }

    function clearViewButtonSelection(utilGroup) {
        // find the other buttons
        var buttonElement = getFirstChild(utilGroup, "button densitySelected");
        if (buttonElement) {
            buttonElement.className = "button density";
        }

        // find the other buttons
        buttonElement = getFirstChild(utilGroup, "button cumulativeSelected");
        if (buttonElement) {
            buttonElement.className = "button cumulative";
        }
    }

    function switchToDensity(buttonElement) {
        // find the button group containing the button
        var utilGroup = getParent(buttonElement, "utilGroup");
        // clear the button selections
        clearViewButtonSelection(utilGroup);

        // "select" the button that was clicked
        buttonElement.className = "button densitySelected";

        // refresh the chart
        redrawHistogram(buttonElement);
    }

    function switchToCumulative(buttonElement) {
        // find the button group containing the button
        var utilGroup = getParent(buttonElement, "utilGroup");
        // clear the button selections
        clearViewButtonSelection(utilGroup);

        // "select" the button that was clicked
        buttonElement.className = "button cumulativeSelected";

        // refresh the chart
        redrawHistogram(buttonElement);
    }

    function toggleQuery(buttonElement) {
        // find the button group containing the button
        var parent = getParent(buttonElement, "histogramSettings");
        var queryTable = getFirstChild(parent, "queryTable");
        if (buttonElement.className == "button query") {
            buttonElement.className = "button querySelected";
            queryTable.style.display = "inline-block";

        } else {
            buttonElement.className = "button query";
            queryTable.style.display = "none";
        }

        // refresh the chart
        updateQuery(parent);
    }

    function redrawHistogram(element) {
        // find the parent result element and redraw the histrogram
        var parent = getParent(element, "trialResult");
        if (!parent) {
            parent = getParent(element, "timeResult");
        }
        updateHistogram(parent);
    }

    function updateResultStatistics(resultElement, customResults) {
        // pull data out of the DOM element
        var title = resultElement.title;
        var unitName = resultElement.unitName;
        var trialData = resultElement.trialData;
        var dataScale = resultElement.dataScale;

        // find and update the statistics element
        var statisticsElement = getFirstChild(resultElement, "statistics");
        var html = `
                        <table class="statsTable">
                        <tr>
                            <td class="statName">
                                <div class="tooltip">
                                    Average:
                                    <span class="tooltipTextBottom">This is the <a href="https://en.wikipedia.org/wiki/Expected_value">expected value</a>, on average.</span>
                                </div>
                            </td>
                            <td class="statValue">
                                ${(trialData.average * dataScale).toFixed(2)}
                            </td>
                        </tr>
            `;
        // loop over all the percentiles
        for (var i = 0; i < percentiles.length; i++) {
            var percentile = percentiles[i];
            var percentileResult = trialData.percentileToResult(percentile) * dataScale;
            if (percentile == 0.5) {
                html += `
                        <tr>
                            <td class="statName">
                                <div class="tooltip">
                                    Median:
                                    <span class="tooltipTextBottom">The <a href="https://en.wikipedia.org/wiki/Median">median</a> is the midpoint of the data set.</span>
                                </div>
                            </td>
                            <td class="statValue">
                                ${percentileResult.toFixed(2)}
                            </td>
                        </tr>
                `;
            } else {
                html += `
                        <tr>
                            <td class="statName">
                                <div class="tooltip">
                                    ${(percentile * 100).toFixed(0)}th Percentile:
                                    <span class="tooltipTextBottom">The expected number of runs required in order to have a ${(percentile * 100).toFixed(0)}% chance of success.</span>
                                </div>
                            </td>
                            <td class="statValue">
                                ${percentileResult.toFixed(2)}
                            </td>
                        </tr>
                `;
            }
        }
        // finish the HTML
        html += `
                        <tr>
                            <td class="statName">
                                <div class="tooltip">
                                    Standard Deviation:
                                    <span class="tooltipTextBottom"><a href="https://en.wikipedia.org/wiki/Standard_deviation">Standard Deviation</a> basically describes how spread out the data is from the average.</span>
                                </div>
                            </td>
                            </td>
                            <td class="statValue">
                                ${(trialData.standardDeviation * dataScale).toFixed(2)}
                            </td>
                        </tr>
                        <tr>
                            <td class="statName">
                                <div class="tooltip">
                                    Skew:
                                    <span class="tooltipTextBottom"><a href="https://en.wikipedia.org/wiki/Skewness">Skew</a> describes how slanted the data is towards one side or the other.</span>
                                </div>
                            </td>
                            </td>
                            <td class="statValue">
                                ${(trialData.skew).toFixed(4)}
                            </td>
                        </tr>
                        <tr>
                            <td class="statName">
                                <div class="tooltip">
                                    Excess Kurtosis:
                                    <span class="tooltipTextBottom"><a href="https://en.wikipedia.org/wiki/Kurtosis">Excess kurtosis</a> basically describes how many extreme outliers there are compared to a normal distribution.</span>
                                </div>
                            </td>
                            <td class="statValue">
                                ${(trialData.kurtosis).toFixed(4)}
                            </td>
                        </tr>
                        <tr>
                            <td class="statName">
                                <div class="tooltip">
                                    Trials:
                                    <span class="tooltipTextBottom">The total number of trials.  Each trial starts from zero and runs each mission in the list until success.</span>
                                </div>
                            </td>
                            <td class="statValue">
                                ${(trialData.numTrials)}
                            </td>
                        </tr>
                        <tr>
                            <td class="statName">
                                <div class="tooltip">
                                    Best case:
                                    <span class="tooltipTextBottom">This is the minimum result from the current simulation run.</span>
                                </div>
                            </td>
                            <td class="statValue">
                                ${(trialData.min * dataScale).toFixed(dataScale < 1 ? 2 : 0)}
                                (${trialData.dist[trialData.min/trialData.scale]}
                                time${trialData.dist[trialData.min/trialData.scale] > 1 ? "s" : ""} -
                                ${(100 * trialData.dist[trialData.min/trialData.scale] / trialData.numTrials).toFixed(2)}%)
                            </td>
                        </tr>
                        <tr>
                            <td colspan="2">
                                <div class="worstCase">
                                    ${trialData.minString}
                                </div>
                            </td>
                        </tr>
                        <tr>
                            <td class="statName">
                                <div class="tooltip">
                                    Worst case:
                                    <span class="tooltipTextBottom">This is the maximum result from the current simulation run.</span>
                                </div>
                            </td>
                            <td class="statValue">
                                ${(trialData.max * dataScale).toFixed(dataScale < 1 ? 2 : 0)}
                            </td>
                        </tr>
                        <tr>
                            <td colspan="2">
                                <div class="worstCase">
                                    ${trialData.maxString}
                                </div>
                            </td>
                        </tr>`;

            // throw custom results in there, if applicable
            if (customResults && customResults != null) {
                for (var i = 0; i < customResults.length; i++) {
                    html += `
                        <tr>
                            <td class="statName">
                                ${customResults[i][0]}:
                            </td>
                            <td class="statValue">
                            </td>
                        </tr>
                        <tr>
                            <td colspan="2">
                                <div class="worstCase">
                                    ${customResults[i][1]}
                                </div>
                            </td>
                        </tr>`;
                }
            }


            html += `
                    </table>
            `;
        statisticsElement.innerHTML = html;
    }

    function updateQuery(resultElement) {
        var queryElement = getFirstChild(resultElement, "histogramSettings");
        if (queryElement) {
            var input = getFirstChild(queryElement, "inputResult");
            calcPercentile(input);
        }
    }

    function updateHistogram(resultElement) {
        // pull data out of the DOM element
        var title = resultElement.title;
        var unitName = resultElement.unitName;
        var trialData = resultElement.trialData;
        var dataScale = resultElement.dataScale;

        // find the canvas element
        var canvas = getFirstChild(resultElement, "histogram");
        if (!canvas) {
            // either the canvas isn't there yet or it got replaced with an image when someone clicked on it
            var canvasContainer = getFirstChild(resultElement, "histogramContainer");
            canvasContainer.innerHTML = `<canvas class="histogram" height=200 width=500 onclick="convertToPng(this);"/>`;
            var canvas = getFirstChild(canvasContainer, "histogram");
        }

        var buttonGroup = getFirstChild(resultElement, "utilGroup");
        var cumulative = getFirstChild(buttonGroup, "button cumulativeSelected") !== null;

        // add to the title according to which histogram it is
        var titles = [title, unitName, cumulative ? "Cumulative Probability" : "Probability Density"];
        // draw the histogram
        histogram(canvas, titles, unitName, trialData, dataScale, cumulative);
    }

	function histogram(canvas, titles, unitName, trialData, dataScale, cumulative) {
	    var canvasStyle = getComputedStyle(canvas);
	    var styleString = canvasStyle.getPropertyValue("content");
	    var style = parseCanvasStyle(styleString);

        // save this in a property so convertToPng() can use it for the file name
	    canvas.saveName = concatenateTitle(titles);

	    // pull out the distribution
		var h = cumulative ? trialData.cDist : trialData.dist;
		// find the 99.9% percentile.  We will cut the data off there, otherwise the data may get very, very wide
		// with the extreme 0.1% outliers.
		var max = Math.ceil(trialData.percentileToResult(0.999));
		//var min90 = Math.floor(trialData.percentileToResult(0.90));
		//var min99 = Math.floor(trialData.percentileToResult(0.99));

        // find the maximum value of the distribution
        if (cumulative) {
            // with the cumulative distribution the maximum value is the total number of trials
            var maxBucket = trialData.numTrials;

        } else {
            // with probabilty density it's already tracking the max value for us
            var maxBucket = trialData.maxBucketValue;
        }

        // get the average so we can mark it
		var average = trialData.average;

        // get the graphics context and clear it
        var context = canvas.getContext("2d");
        context.fillStyle = style['bg'];
        context.fillRect(0, 0, canvas.width, canvas.height);

        // just pick a font size
        var fontSize = Number.parseInt(style['fs']);

        // flat number of pixels to leave as space around the graph
        var margin = 5;

        // calculate the actual graph size, leaving room on the left and bottom for the axes

        // the Y axis label is only useful with the cumulative distribution
        if (cumulative) {
            // leave room for a percentage
            var graphWidth = canvas.width - (fontSize * 3);

        } else {
            var graphWidth = canvas.width - (fontSize * 1);
        }
        var graphHeight = canvas.height - (fontSize * 1.1) - margin;

        // convenience starting X coordinate for the graph
        var graphXStart = canvas.width - graphWidth;

        // all bars will have the same width
        var width = Math.ceil((graphWidth) / ((max/trialData.scale) + 1));
        // all bars will start at the bottom of the graph
        var y1 = graphHeight;

        // set the data color
        context.fillStyle = style['b'];
        // draw the bars
        for (var t = 0; t < max/trialData.scale; t++) {
            /* Meh, not on board with this yet
            if (t == min90) {
                context.fillStyle = style['b90'];
            } else
            if (t == min99) {
                context.fillStyle = style['b99'];
            }
            */
            // calculate the x position of the left side of the bar
            var x1 = Math.floor(graphXStart + (t * (graphWidth - margin)) / ((max/trialData.scale) + 1));
            // calculate the height of the bar
            var height = -(h[t] * (graphHeight - margin) / maxBucket);

            // draw the bar
            context.fillRect(x1, y1, width, height);
        }

        // have to draw the average bar highlight afterwards, separately, or it might be lost in distributions
        // with more buckets than horizontal pixels.
        {
            var t = Math.floor(average / trialData.scale);
            // calculate the x position of the left side of the bar
            var x1 = Math.floor(graphXStart + (t * (graphWidth - margin)) / ((max/trialData.scale) + 1));
            // calculate the height of the bar
            var height = -(h[t] * (graphHeight - margin) / maxBucket);

            // if this bucket contains the average, color the background
            // some distributions are sparse and don't actually have a visible value in the bucket containing the
            // average, so this lets us see those
            context.fillStyle = style['bhbg'];
            // draw the background bar for the average
            context.fillRect(x1, margin, width, graphHeight + height - margin);

            // set the data color for the average a bit brighter
            context.fillStyle = style['bh'];
            // draw the bar
            context.fillRect(x1, y1, width, height);
        }

        // draw the axis borders
        context.strokeStyle = style['l'];
        context.lineWidth = fontSize/10;
        context.beginPath();
        context.moveTo(graphXStart, margin);
        context.lineTo(graphXStart, graphHeight);
        context.lineTo(canvas.width - margin, graphHeight);
        context.stroke();

        // set up the text
        context.font = fontSize + "px Arial";
        context.textAlign = "left";

        var xAxisLabelCount = 10;

        if (max <= xAxisLabelCount) {
            var xAxisIncrement = 1;

        } else {

            // Scale back the number of labels when the actual values are huge
            var maxLabelLength = (max * dataScale).toFixed(0).length;
            // The larger the label length, the fewer labels we can have
            if (maxLabelLength > 5) {
                xAxisLabelCount = 6;
            } else if ((max * dataScale).toFixed(0).length > 4) {
                xAxisLabelCount = 8;
            }

            // calculate an increment for the x axis that gives us up to 10 labels
            var xAxisIncrement = Math.ceil(max / (xAxisLabelCount*xAxisLabelCount)) * xAxisLabelCount;
            // If there is a fractional data scale, pick an increment nearby which gives whole numbers when multiplied by
            // the data scale.
            if (dataScale < 1) {
                xAxisIncrement = Math.round(Math.ceil(xAxisIncrement * dataScale) / dataScale);
            }
        }

        // loop over the increments
        for (var t = 0; t <= max; t+= xAxisIncrement) {
            // calculate the X coordinate of the axis
            var x1 = graphXStart + ((t + 0.5) * (graphWidth - margin)) / (max + 1);
            // starting Y coord is the bottom of the graph
            var y1 = graphHeight;
            // draw the tick
            context.beginPath();
            context.moveTo(x1, y1);
            context.lineTo(x1, y1 + (fontSize * 0.5));
            context.stroke();
            // get the label as a string
            var s = Math.round(t * dataScale).toFixed(0);
            // check if the string is probably too wide to fit before drawing it
            if (canvas.width - x1 > (s.length * fontSize)) {
                context.fillText(s, x1 + (fontSize / 4), y1 + (fontSize * 1.0));
            }
        }

        if (cumulative) {
            // the Y axis label is only useful with the cumulative distribution
            context.textAlign = "right";
            // just increment from 0% to 90%
            var yAxisIncrement = 20;
            for (var t = 0; t < 100; t+= yAxisIncrement) {
                var x1 = graphXStart;
                var y1 = graphHeight - ((t + 0.5) * graphHeight) / (100);
                context.beginPath();
                context.moveTo(x1, y1);
                context.lineTo(x1 - (fontSize * 0.5), y1);
                context.stroke();
                context.fillText(t + "%", x1 - (fontSize / 4), y1 - (fontSize * 0.25));
            }
        }

        if (trialData.average > max/2) {
            // data is closer to a normal distribution, put the text on the left
            var textX = canvas.width - (graphWidth * 0.67);

        } else {
            // data is closer to a skewed negative binomial distribution, put the text on the right
            var textX = canvas.width - (graphWidth * 0.25);
        }

        context.fillStyle = style['t'];
        context.strokeStyle = style['to'];
        context.lineWidth = fontSize * 0.33;
        context.miterLimit = 2;

        // draw all the outlines first
    	histogramText(context, textX, fontSize * 2, canvas.width, trialData, titles, unitName, fontSize, dataScale, true);

        // draw the text on top
    	histogramText(context, textX, fontSize * 2, canvas.width, trialData, titles, unitName, fontSize, dataScale, false);

	}

	function histogramText(context, textX, textY, canvasWidth, trialData, titles, unitName, fontSize, dataScale, outline) {
	    // just easier
        textY -= fontSize;

        // bold text for the title
        context.font = "bold " + fontSize + "px Arial";
        // center the title
        context.textAlign = "center";

        for (var i = 0; i < titles.length; i++) {
            // increment the Y coord
            textY += fontSize;
            var s = fitCenteredText(context, titles[i], textX, canvasWidth)
            // draw the title
            doText(context, s, textX, textY, outline);
        }

        // increment the Y coord for a blank space
        textY += fontSize;

        // increment the Y coord
        textY += fontSize;
        // Average label on the right
        context.textAlign = "right";
        doText(context, "Average:", textX - (fontSize * 0.5), textY, outline);
        // Average value on the left
        context.textAlign = "left";
        doText(context, (trialData.average * dataScale).toFixed(2), textX + (fontSize * 0.5), textY, outline);

        // loop over the percentiles
        for (var i = 0; i < percentilesForHistogram.length; i++) {
            var percentile = percentilesForHistogram[i];
            // get the result object to calculate the percentile for us
            var percentileResult = trialData.percentileToResult(percentile) * dataScale;

            // increment the Y coord
            textY += fontSize;
            // label on the right
            context.textAlign = "right";
            doText(context, (percentile * 100).toFixed(0) + "th Percentile:", textX - (fontSize * 0.5), textY, outline);
            // value on the left
            context.textAlign = "left";
            doText(context, percentileResult.toFixed(2), textX + (fontSize * 0.5), textY, outline);
        }

        /* Meh, don't put this on the chart
        // increment the Y coord
        textY += fontSize;
        // label on the right
        context.textAlign = "right";
        doText(context, "Worst Case:", textX - (fontSize * 0.5), textY, outline);
        // value on the left
        context.textAlign = "left";
        doText(context, (trialData.max * dataScale).toFixed(dataScale < 1 ? 2 : 0), textX + (fontSize * 0.5), textY, outline);
        */

        // increment the Y coord
        textY += fontSize;
        // back to regular font
        context.font = fontSize + "px Arial";
        // Trials label on the right
        context.textAlign = "right";
        doText(context, "Trials:", textX - (fontSize * 0.5), textY, outline);
        // Trials data on the right
        context.textAlign = "left";
        doText(context, trialData.numTrials, textX + (fontSize * 0.5), textY, outline);
	}

	function doText(context, text, x, y, outline) {
	    // we do the whole thing once with outlines, then again with the regular text
	    if (outline) {
            context.strokeText(text, x, y);

        } else {
            context.fillText(text, x, y);
        }
	}

	function fitCenteredText(context, text, textX, canvasWidth) {
	    // shorten the text if necessary so it all fits on the canvas
	    var t = text;
	    for (;;) {
	        // use the canvas context to measure how wide the text is with the current font
	        // divide by two because we're centering it at textX
	        var w = context.measureText(t).width / 2;
	        // check to see if it goes beyond the left or right side on the canvas
	        if (w <= textX && w + textX <= canvasWidth) {
	            // we're good
	            return t;
	        }
	        // todo: something more efficient than just conting down one character at a time?
	        t = t.substring(0, t.length - 4) + "...";
	    }
	}

    function convertToPng(canvas) {
        // quick and easy replace a canvas element with an equivalent image element for easy download

        // builds a huuuuge URL with the base-64 encoded PNG data embedded inside it
        var src = canvas.toDataURL();
        // todo: this doesn't work
        var fileName = canvas.saveName + ".png";
        // replace the canvas with an image
        // Ugh, the only way to give it a file name is to wrap it in a link element, and duplicate the entire src contents.
        canvas.parentElement.innerHTML = `
            <a download="${fileName}" href="${src}">
                <image src="${src}"></image>
            </a>
        `;
    }

    function parseCanvasStyle(styleString) {
        // quick and dirty parser for the canvas CSS style hack
        var style = new Array();
        var regex = /([^";=]+)=([^";=]+)/g;
        var match;
        while (match = regex.exec(styleString)) {
            style[match[1]] = match[2];
        }
        // return an associative array
        return style;
    }

    function concatenateTitle(titles) {
        // quick and dirty concatenate the parts of the title with hyphens
        var html = "";
        for (var i = 0; i < titles.length; i++) {
            if (i > 0) {
                html += " - ";
            }
            html += titles[i];
        }
        return html;
    }

    function updateRivenCriterionResult(resultElement, total, rivenPosStatMatches, rivenNegStatMatches) {
        var html = `
                <table class="rivenStatTable">
                    <tr>
                        <td>
                            <strong>Positive Stats Accepted</strong>
                            <table class="statTable">`;

        for (var index = 0; index < rivenPosStatMatches.length; index++) {
            if (rivenPosStatMatches[index] > 0) {
                html += `
                                <tr><td>${getStatName(index)}: </td><td>${(rivenPosStatMatches[index] * 100 / total).toFixed(0)}%</td></tr>`;
            }
        }

        html += `
                            </table>
                        </td>
                        <td>
                            <strong>Negative Stats Accepted</strong>
                            <table class="statTable">`;

        for (var index = 0; index < rivenNegStatMatches.length; index++) {
            if (rivenNegStatMatches[index] > 0) {
                html += `
                                <tr><td>${getStatName(index)}: </td><td>${(rivenNegStatMatches[index] * 100 / total).toFixed(0)}%</td></tr>`;
            }
        }

        html += `
                            </table>`;

        resultElement.innerHTML = html;
    }

    function updateAllResults(scenarioRunner) {
        document.getElementById("clearResultsButton").disabled = false;

        // update mission-level results, if there is more than one mission
		if (scenarioRunner.missionRunners.length > 1) {
            for (var i = 0; i < scenarioRunner.missionRunners.length; i++) {
                var missionRunner = scenarioRunner.missionRunners[i];

                // update the number of trials results
                updateResult(
                    getFirstChild(missionRunner.mission.resultElement, "trialResult"),
                    shorten(scenarioRunner.scenario.name) + " Count",
                    shorten(missionRunner.mission.name) + " Missions",
                    missionRunner.totalResults, false);

                // update the time results, or clear it if there is no time results
                var timeResult = getFirstChild(missionRunner.mission.resultElement, "timeResult");
                if (timeResult) {
                    updateResult(
                        timeResult,
                        shorten(scenarioRunner.scenario.name),
                        shorten(missionRunner.mission.name) + " Time",
                        missionRunner.totalTimeResults, true);
                }
            }
        }

        /* Currently not that useful outside of debugging Riven rolls
        for (var i = 0; i < scenarioRunner.missionRunners.length; i++) {
            var missionRunner = scenarioRunner.missionRunners[i];
            missionRunner.customResultUI();
        }
        */

        // update the total number of trials results
		updateResult(
		    getFirstChild(scenarioRunner.scenario.resultElement, "trialResult"),
		    shorten(scenarioRunner.scenario.name),
		    scenarioRunner.missionRunners.length == 1 ? (shorten(scenarioRunner.missionRunners[0].mission.name) + " Count") : "Total Missions",
		    scenarioRunner.totalResults, false, scenarioRunner.customResults());

        // update the total time results, or clear it if there is no time results
        updateResult(
            getFirstChild(scenarioRunner.scenario.resultElement, "timeResult"),
		    shorten(scenarioRunner.scenario.name),
		    scenarioRunner.missionRunners.length == 1 ? (shorten(scenarioRunner.missionRunners[0].mission.name) + " Time") : "Total Mission Time",
            scenarioRunner.totalTimeResults, true);
    }

    var max_name_size = 40;

    function shorten(s) {
        // This is just to keep the HTML layout from getting wonky
        // There is another length checking step inside the chart builder
        if (s.length <= max_name_size) {
            return s;
        }
        return s.substring(0, max_name_size - 3) + "...";
    }

    function clearResults() {
        // clear the overall trial and time result elements
        var scenarioResults = document.getElementById("scenarioResults");
	    getFirstChild(scenarioResults, "trialResult").innerHTML = "";
	    getFirstChild(scenarioResults, "timeResult").innerHTML = "";

        if (scenarioRunner != null) {
            for (var m = 0; m < scenarioRunner.missionRunners.length; m++) {
                // clear the trial and time result elements for each individual mission, if applicable
                var resultElement = scenarioRunner.missionRunners[m].mission.resultElement
                if (resultElement) {
                    getFirstChild(resultElement, "trialResult").innerHTML = "";
                    var timeResult = getFirstChild(resultElement, "timeResult");
                    if (timeResult) {
                        timeResult.innerHTML = "";
                    }
                }
                /* Currently not that useful outside of debugging Riven rolls
                scenarioRunner.missionRunners[m].clearCustomResultUI();
                */
            }

    	    scenarioRunner = null;
        }

        document.getElementById('clearResultsButton').disabled = true;
    }

    function stopAndclearResults() {
        stopRun();
        clearResults();
    }

    //==============================================================
    // Runner
    //==============================================================

    // global variable for simulation running
    var scenarioRunner;

    // run state
    var running = false;
    var stopped = true;

    // this is the number of runs after which we will stop
    // this is set on start, and can be incremented if start is used again after auto-stop occurs
    var stopNum = 0;

    // This is how long we will run the simulation before updating the UI
    var chunkMs = 100;

    function startRun() {
        // disable/enable everything accordingly
        document.getElementById('startButton').disabled = true;
        document.getElementById('startDiv').className = "utilHidden";
        document.getElementById('samplesSelect').disabled = true;
        document.getElementById('stopAfter').disabled = true;
        setAllInputsDisabled(getScenario(), true);
        document.getElementById('stopButton').disabled = false;
        document.getElementById('stopDiv').className = "util";
        document.getElementById('clearButton').disabled = true;

        // update state
        stopped = false;

        // parse the UI into a model
        var model = getModel();

        // check if we already have a run in progress
        if (scenarioRunner != null) {
            // check if the model has changed by comparing toString()s.
            if (model.toString() == scenarioRunner.scenario.toString()) {
                // model hasn't changed, we can just resume where we left off

                // read the auto stop number from the UI
                var stopAfter = readInt(document.getElementById('stopAfter').value);

                if (stopAfter == 0) {
                    // If the user has entered 0 for stopAfter then run until stop is clicked.
                    stopNum = Number.MAX_SAFE_INTEGER;

                } else {
                    // Run until we hit the next multiple of stopAfter
                    // add 1 to the current total in case we're currently at a multiple, or 0.
                    stopNum = stopAfter * (Math.ceil((scenarioRunner.totalResults.numTrials + 1) / stopAfter));
                }

            } else {
                // otherwise, start over
                scenarioRunner = null;
            }
        }

        if (scenarioRunner == null) {
            // we're starting over, clear out all previous result UIs
            clearResults();
            // build a new runner
            scenarioRunner = new ScenarioRunner(model);

            // check for errors
            var errors = scenarioRunner.verify();
            if (errors.length > 0) {
                // oops!  there are errors.  Show them
                showErrors(errors);
                // clear the runner
                scenarioRunner = null;
                // sanity stop
                stopRun();
            } else {
                // everything's fine, clear out any previous errors
                clearErrors();
            }

            // initialize the auto stop number
            stopNum = readInt(document.getElementById('stopAfter').value);
        }

        // start the simulation
        runChunk();
    }

    function stopRun() {
        // disable/enable everything accordingly
        document.getElementById('startButton').disabled = false;
        document.getElementById('startDiv').className = "util";
        document.getElementById('samplesSelect').disabled = false;
        document.getElementById('stopAfter').disabled = false;
        setAllInputsDisabled(getScenario(), false);
        // the previous method will indiscriminately enable everthing, so we need to re-set the "Add X" buttons' states
        updateAddMissionRivenButtons();
        document.getElementById('stopButton').disabled = true;
        document.getElementById('stopDiv').className = "utilHidden";
        document.getElementById('clearButton').disabled = false;
        // update state
        stopped = true;
        // the running simulation will check the stopped flag eventually and stop itself
    }

    function setAllInputsDisabled(node, disabled) {
        // quick and dirty way to disable/enable all inputs under the scenario config

        // basically we're looking for everything that has a disabled property and it's not set the way we want
        if (node.disabled == !disabled) {
            node.disabled = disabled;

        } else {
            // recursively search the child elements
            var children = node.children;
            for(var i = 0; i < children.length; i++) {
                setAllInputsDisabled(children[i], disabled);
            }
        }
    }

    function runChunk() {
        // preemptive check.  Since everything happens on the same event thread, the stop button event usually gets
        // handled in between runChunk()s.
        if (stopped) {
            // update state
            running = false;
            return;
        }

        // set state
        running = true;

        // we'll run trials until 100ms from now
        // on second thought, since we're basically doubling the chunk size every iteration, lets try and keep it
        // between 50ms and 100ms.
        var endTime = Date.now() + chunkMs/2;

        // start off with a chunk size of 1, we'll optimize this as we go so that one chunk takes "around" 100ms.
        // this is the "index" if the chunk size, see getChunkSize()
        var chunkSizeN = 0;
        var chunkSize = getChunkSize(chunkSizeN);

        var trialCount = scenarioRunner.trialCount ? scenarioRunner.trialCount : 0;

        // run the trials
		for (;;) {
            trialCount++;
			scenarioRunner.run();

            // check the stop num
            if (stopNum > 0 && scenarioRunner.totalResults.numTrials >= stopNum) {
                break;
            }

			// check the time at the end of the current chunk size
			if (trialCount % chunkSize == 0) {
			    if (Date.now() >= endTime) {
    		        break;

    		    } else {
    		        // chunkSize *= 2;
    		        // instead of just doubling, let's make it look a little nicer by staying close to numbers with lots
    		        // of zeroes.
    		        chunkSizeN++;
    		        chunkSize = getChunkSize(chunkSizeN);
    		    }
			}
		}

		scenarioRunner.trialCount = trialCount;

        // update all the result UIs
        updateAllResults(scenarioRunner);

        // check if we've hit the stop after number
        if (stopNum > 0 && scenarioRunner.totalResults.numTrials >= stopNum) {
            // do this after updating the results UI
            stopRun();
        }

        // check stopped flag
        if (!stopped) {
            // cheap and easy way to emulate a background thread.  throw another chunk of runs on the UI event thread
            // and schedule it to run in 10ms.
            // todo: this may increase the call stack without bound?
            setTimeout(runChunk, 10);

        } else {
            // we're stopped, update state
            running = false;
        }
    }

    function getChunkSize(n) {
        // Ths sequence goes: 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 5000, etc.
        var ordinal = n % 3;
        var magnatude = (n - ordinal) / 3;

        var size = ordinal == 0 ? 1 :
                   ordinal == 1 ? 2 :
                   5;
        for (var i = 0; i < magnatude; i++) {
            size *= 10;
        }
        return size;
    }

    function about() {
        var container = document.getElementById("lotsOfWordsContainer")

        if (container.style.display === "none") {
            container.style.display = "block";

            // perform some history shenanigans to make sure that if you display Help, click a link, and then go back,
            // then Help is still displayed and you don't lose your place.
            var href = window.location.href;

            // make sure the back button doesn't restart the simulation
            if (href.indexOf(autoStartUrlString) > 0) {
                href = href.replace(autoStartUrlString, "");
            }

            if (href.indexOf(showHelpUrlString) < 0) {
                if (href.indexOf("?") < 0) {
                    href += "?";
                }
                href += showHelpUrlString;
                history.replaceState( {} , document.title, href );
            }

        } else {
            container.style.display = "none";
            var href = window.location.href;
            var index = href.indexOf(showHelpUrlString)
            if (index >= 0) {
                href = href.substring(0, index) + href.substring(index + showHelpUrlString.length);
                history.replaceState( {} , document.title, href );
            }
        }
    }




</script>
<body onload="initModel()">

<div class="titleBar">
    <div class="mainTitle">Warframe RNG Simulator</div>
    <div class="businessDiv">
        <div class="utilGroup">
            <div class="util examplesDiv">
                Examples:
                <span class="tooltip">
                    <select id="samplesSelect" onchange="reinitModel(this.value)">
                        <option value="" disabled selected>Select one...</option>
                        <option value="" disabled>---Frames---</option>
                        <!-- These frame samples are in rough order from least to most average time -->
                        <option value="?m=Standard+Boss+Frame_{m_Assassinate_0_10_y_{d_Complete_1_0_0_{i_Helmet_38.7200_1_1}_{i_Chassis_38.7200_1_1}_{i_Systems_22.5600_1_1}}}&s=1000000">Standard Boss Frame</option>
                        <option value="?m=Ash_{e_Grineer+Manic_0_0_y_{d_Kill_1_0_0_{i_Chassis_12.7776_1_1}_{i_Helmet_12.7776_1_1}_{i_Systems_7.4480_1_1}}}&s=1000000">Ash</option>
                        <option value="?m=Gara_{m_Bounty+5-15_0_0_y_{d_Stage+2_1_0_6_{i_Chassis_7.5200_1_1}}_{d_Stage+3_1_0_3_{i_Chassis_30.5600_1_1}}}_{m_Bounty+10-20_0_0_y_{d_Stage+2_1_0_6_{i_Systems_9.5200_1_1}}_{d_Stage+3_1_0_3_{i_Systems_21.8200_1_1}}}_{m_Bounty+20-30_0_0_y_{d_Stage+3_1_0_9_{i_Helmet_8.4200_1_1}}_{d_Stage+4_1_0_3_{i_Helmet_20.5100_1_1}}}&s=1000000">Gara</option>
                        <option value="?m=Garuda_{m_Bounty+5-15_0_0_y_{d_Stage+2_1_0_6_{i_Chassis_7.5200_1_1}}_{d_Stage+3_1_0_3_{i_Chassis_30.5600_1_1}}}_{m_Bounty+10-20_0_0_y_{d_Stage+2_1_0_6_{i_Systems_7.4100_1_1}}_{d_Stage+3_1_0_3_{i_Systems_22.2200_1_1}}}_{m_Bounty+20-30_0_0_y_{d_Stage+3_1_0_9_{i_Helmet_12.5000_1_1}}_{d_Stage+4_1_0_3_{i_Helmet_25.0000_1_1}}}&s=1000000">Garuda</option>
                        <option value="?m=Protea_{m_Granum+Void_0_5_y_{d_Rotation+C_1_0_0_0_{i_Protea+Neuroptics_11.1100_1_1}}}_{m_Extended+Granum+Void_0_5_y_{d_Rotation+C_1_0_0_0_{i_Protea+Chassis_11.1100_1_1}}}_{m_Nightmare+Granum+Void_0_5_y_{d_Rotation+C_1_0_0_0_{i_Protea+Systems_11.1100_1_1}}}&s=1000000">Protea</option>
                        <option value="?m=Octavia_{m_ODS_0_0_y_{d_Rotation+C_1_0_20_{i_Helmet_22.5600_1_1}}}_{m_Lua+Crossfire+With+Caches,+Music+Room_0_5_y_{d_Music+Room+(guessing+at+spawn+rate)_1_1_0_{i_Chassis_25.0000_1_1}}_{d_Cache+A_1_0_5_{i_Systems_22.5600_1_1}}}&s=1000000">Octavia</option>
                        <option value="?m=Revenant_{m_Bounty+20-40_0_3_y_{d_Stage+2_1_0_3_{i_Systems_8.8700_1_1}}_{d_Stage+3_1_0_3_{i_Systems_8.6833_1_1}}_{d_Stage+4_1_0_3_{i_Systems_20.1700_1_1}}}_{m_Bounty+30-50_0_3_y_{d_Stage+2,3_2_0_3_{i_Chassis_8.4500_1_1}}_{d_Stage+4_1_0_3_{i_Chassis_8.2733_1_1}}_{d_Stage+5_1_0_3_{i_Chassis_19.3667_1_1}}}_{m_Bounty+40-60_0_9_y_{d_Stage+4_1_0_3_{i_Helmet_6.7600_1_1}}_{d_Stage+5_1_0_3_{i_Helmet_10.0200_1_1}}}&s=1000000">Revenant</option>
                        <option value="?m=Revenant+(no+bail+early)_{m_Bounty+20-40_0_3_n_{d_Stage+2_1_0_3_{i_Systems_8.8700_1_1}}_{d_Stage+3_1_0_3_{i_Systems_8.6833_1_1}}_{d_Stage+4_1_0_3_{i_Systems_20.1700_1_1}}}_{m_Bounty+30-50_0_3_n_{d_Stage+2,3_2_0_3_{i_Chassis_8.4500_1_1}}_{d_Stage+4_1_0_3_{i_Chassis_8.2733_1_1}}_{d_Stage+5_1_0_3_{i_Chassis_19.3667_1_1}}}_{m_Bounty+40-60_0_9_n_{d_Stage+4_1_0_3_{i_Helmet_6.7600_1_1}}_{d_Stage+5_1_0_3_{i_Helmet_10.0200_1_1}}}&s=1000000">Revenant (no bail early)</option>
                        <option value="?m=Gauss_{m_Kelpie+-+8+rounds_0_10_y_{d_Rotation+C_6_0_5_0_{i_Chassis_7.8400_1_1}_{i_Neuroptics_7.8400_1_1}_{i_Systems_7.8400_1_1}}}&s=1000000">Gauss - 8 rounds</option>
                        <option value="?m=Harrow_{m_Pago_0_5_y_{d_Rotation+C_1_0_0_0_{i_Neuroptics_11.2800_1_1}}}_{m_Mid-level+Defection_0_0_y_{d_Rotation+B_1_0_15_0_{i_Systems_2.0100_1_1}}_{d_Rotation+C_1_0_5_0_{i_Systems_11.2800_1_1}}}&s=1000000">Harrow</option>
                        <option value="?m=Equinox_{m_Uranus+Assassinate_0_10_y_{d_Kill+Tyl_1_0_0_{i_Night+Aspect_11.2800_1_1}_{i_Night+Chassis_12.9100_1_1}_{i_Night+Systems_12.9100_1_1}_{i_Night+Helmet_12.9100_1_1}_{i_Day+Aspect_11.2800_1_1}_{i_Day+Chassis_12.9100_1_1}_{i_Day+Systems_12.9100_1_1}_{i_Day+Helmet_12.9100_1_1}}}&s=1000000">Equinox</option>
                        <option value="?m=Gauss_{m_Kelpie+-+4+rounds_0_10_y_{d_Rotation+C_2_0_5_0_{i_Chassis_7.8400_1_1}_{i_Neuroptics_7.8400_1_1}_{i_Systems_7.8400_1_1}}}&s=1000000">Gauss - 4 rounds</option>
                        <option value="?m=Nidus_{m_Infested+Salvage_0_0_y_{d_Rotation+C_1_0_20_{i_Systems_14.2900_1_1}_{i_Helmet_14.2900_1_1}_{i_Chassis_14.2900_1_1}}}&s=1000000">Nidus</option>
                        <option value="?m=Ivara_{m_Tier+1+Spy_0_10_y_{d_Rotation+C_1_0_0_{i_Systems_9.0900_1_1}}}_{m_Tier+2+Spy_0_10_y_{d_Rotation+C_1_0_0_{i_Chassis_5.6400_1_1}}}_{m_Tier+3+Spy_0_10_y_{d_Rotation+C_1_0_0_{i_Helmet_7.5200_1_1}_{i_BP_7.5200_1_1}}}&s=1000000">Ivara</option>
                        <option value="?m=Khora_{m_Onslaught_0_0_y_{d_Rotation+A_2_0_5_{i_Chassis_8.3300_1_1}}_{d_Rotation+B_1_0_5_{i_Helmet_7.6900_1_1}}_{d_Rotation+C_1_0_5_{i_Systems_5.6400_1_1}_{i_BP_5.6400_1_1}}}&s=1000000">Khora</option>
                        <!-- The simulation isn't really built for these, but they do work -->
                        <option value="?m=" disabled>---Mods---</option>
                        <option value="?m=Argon+Scope_{e_Torment_0_0_y_{d_Kill_1_0_0_{i_Argon+Scope_4.0400_1_1}}}&s=1000000">Argon Scope</option>
                        <option value="?m=All+Mods+From+An+Acolyte_{e_Acolyte_0_0_y_{d_Kill_1_0_0_{i_Argon+Scope_4.0400_1_1}_{i_Hydraulic+Crosshairs_51.5200_1_1}_{i_Laser+Sight_22.2200_1_1}_{i_Blood+Rush_22.2200_1_1}}}&s=1000000">All Mods From An Acolyte</option>
                        <option value="?m=Fetch_{e_Orb+Vallis+Hyena_0_0_y_{d_Kill_1_0_0_{i_Fetch_1.3790_1_1}}}&s=1000000">Fetch</option>
                        <option value="?m=Four+Riders_{e_Grineer+Manic_0_0_y_{d_Kill_1_0_0_{i_Four+Riders_0.3350_1_1}}}&s=1000000">Four Riders</option>
                        <option value="?m=Bullet+Dance_{m_Marduk_0_0_y_{d_Rotation+C_1_0_0_{i_Bullet+Dance_4.4200_1_1}}}&s=1000000">Bullet Dance</option>
                        <option value="?m=Vengeful+Revenant_{e_Conculyst_0_0_y_{d_Kill_1_0_0_{i_Vengeful+Revenant_0.4170_1_1}}}&s=1000000">Vengeful Revenant</option>
                        <option value="?m=Tempo+Royale+(Bursa)_{e_Isolator+Bursa_0_0_y_{d_Kill_1_0_0_{i_Tempo+Royale_0.0603_1_1}}}&s=1000000">Tempo Royale (Bursa)</option>
                        <option value="?m=Tempo+Royale+(Incursion)_{m_Plains+Incursion_0_5_y_{d_Rotation+A_1_0_0_{i_Tempo+Royale_1.0100_1_1}}}&s=1000000">Tempo Royale (Incursion)</option>
                        <option value="?m=Condition+Overload_{e_Drekar+Butcher_0_0_y_{d_Kill_1_0_0_{i_Condition+Overload_0.0201_1_1}}}&s=100000">Condition Overload</option>
                        <option value="?m=Guardian+Derision_{e_Prod+Crewman_0_0_y_{d_Kill_1_0_0_{i_Guardian+Derision_0.0150_1_1}}}&s=1000000">Guardian Derision</option>
                        <option value="?m=Full+Hunter+Set+(Ghouls)_{m_Level+15-25+Ghoul+Bounty_0_0_y_{d_Stage+1_1_0_3_{i_Adrenaline_33.3300_1_1}}_{d_Stage+2,+3_2_0_3_{i_Adrenaline_11.7400_1_1}_{i_Munitions_9.3900_1_1}}_{d_Stage+4_1_0_3_{i_Munitions_11.9000_1_1}_{i_Track_11.9000_1_1}}}_{m_Level+40-50+Ghoul+Bounty_0_0_y_{d_Stage+1_1_0_3_{i_Recovery_33.3300_1_1}}_{d_Stage+2,+3_2_0_3_{i_Recovery_11.7400_1_1}_{i_Synergy_9.3900_1_1}}_{d_Stage+4_1_0_3_{i_Recovery_10.2900_1_1}_{i_Synergy_8.2300_1_1}_{i_Command_8.2300_1_1}}_{d_Stage+5_1_0_3_{i_Synergy_11.9000_1_1}_{i_Command_11.9000_1_1}}}&s=1000000">Full Hunter Set (Ghouls)</option>
                        <option value="?m=Full+Hunter+Set+(Plague+Star)_{m_Plague+Star_0_15_y_{d_Kill+Hemocyte_4_0_0_{i_Hunter+Command_10.5300_1_1}_{i_Hunter+Recovery_28.9500_1_1}_{i_Hunter+Synergy_10.5300_1_1}_{i_Hunter+Munitions_10.5300_1_1}_{i_Hunter+Track_10.5300_1_1}_{i_Hunter+Adrenaline_28.9500_1_1}}}&s=1000000">Full Hunter Set (Plague Star)</option>
                        <option value="?m=Full+Synth/Mecha/Tek+Set_{m_Bounty+10-30_0_0_y_{d_Stage+3_1_0_3_{i_Synth+Charge_22.2200_1_1}}}_{m_Bounty+20-40_0_0_y_{d_Stage+4_1_0_3_{i_Synth+Deconstruct_25.0000_1_1}}}_{m_Bounty+30-50_0_15_y_{d_Stage+4_1_0_3_{i_Synth+Fiber_10.9900_1_1}}_{d_Stage+5_1_0_0_{i_Synth+Fiber_34.4800_1_1}}}_{m_Bounty+40-60_0_15_y_{d_Stage+4_1_0_0_{i_Synth+Reflex_14.2900_1_1}}_{d_Stage+5_1_0_0_{i_Synth+Reflex_33.3300_1_1}}}&s=1000000">Full Synth/Mecha/Tek Set</option>
                        <option value="?m=All+Corrupted+Mods_{m_Derelict+Exterminate_0_5_y_{d_Vault_1_0_0_{i_Spoiled+Strike_4.1700_1_1}_{i_Corrupt+Charge_4.1700_1_1}_{i_Hollow+Point_4.1700_1_1}_{i_Magnum+Force_4.1700_1_1}_{i_Tainted+Clip_4.1700_1_1}_{i_Critical+Delay_4.1700_1_1}_{i_Heavy+Caliber_4.1700_1_1}_{i_Tainted+Mag_4.1700_1_1}_{i_Vile+Precision_4.1700_1_1}_{i_Narrow+Minded_4.1700_1_1}_{i_Fleeting+Expertise_4.1700_1_1}_{i_Blind+Rage_4.1700_1_1}_{i_Overextended_4.1700_1_1}_{i_Tainted+Shell_4.1700_1_1}_{i_Vicious+Spread_4.1700_1_1}_{i_Burdened+Magazine_4.1700_1_1}_{i_Anemic+Agility_4.1700_1_1}_{i_Vile+Acceleration_4.1700_1_1}_{i_Frail+Momentum_4.1700_1_1}_{i_Critical+Deceleration_4.1700_1_1}_{i_Creeping+Bullseye_4.1700_1_1}_{i_Transient+Fortitude_4.1700_1_1}_{i_Depleted+Reload_4.1700_1_1}}}&s=1000000">All Corrupted Mods</option>
                        <option value="?m=Profit-Taker:+All+Mods_{m_Profit-Taker+Phase+1_0_5_y_{d_Complete_1_0_0_{i_Quick+Reload_15.0000_1_1}_{i_Deadly+Efficiency_1.2500_1_1}_{i_Strain+Eruption_1.2500_1_1}}}_{m_Profit-Taker+Phase+2_0_2_y_{d_Complete_1_0_0_{i_Resolute+Focus_15.0000_1_1}_{i_Arch-Gun+Ace_1.2500_1_1}_{i_Strain+Fever_1.2500_1_1}}}_{m_Profit-Taker+Phase+3_0_5_y_{d_Complete_1_0_0_{i_Marked+Target_15.0000_1_1}_{i_Sabot+Rounds_1.2500_1_1}_{i_Strain+Infection_1.2500_1_1}}}_{m_Profit-Taker+Phase+4_0_10_y_{d_Complete_1_0_0_{i_Ammo+Chain_17.1400_1_1}_{i_Critical+Focus_1.4300_1_1}_{i_Strain+Consume_1.4300_1_1}}}&s=1000000">Profit-Taker: All Mods</option>
                        <!-- Relic-related scenarios -->
                        <option value="?m=" disabled>---Relics---</option>
                        <option value="?m=Radshare_{m_Fissure_0_0_y_{d_Crack+Relic_4_0_0_{i_Rare_10.0000_1_1}}}&s=1000000">Radshare</option>
                        <option value="?m=Solo+Radiant_{m_Fissure_0_0_y_{d_Crack+Relic_1_0_0_{i_Rare_10.0000_1_1}}}&s=1000000">Solo Radiant</option>
                        <option value="?m=Uncommon+Intact+Share_{m_Fissure_0_0_y_{d_Crack+Relic_4_0_0_{i_Uncommon_11.0000_1_1}}}&s=1000000">Uncommon Intact Share</option>
                        <option value="?m=Uncommon+Radshare_{m_Fissure_0_0_y_{d_Crack+Relic_4_0_0_{i_Uncommon_20.0000_1_1}}}&s=1000000">Uncommon Radshare</option>
                        <!-- no current vaulted relics
                        <option value="?m=Three+Axi+S3+Relics+(Mot)_{m_Mot_0_0_y_{d_Rotation+C_1_0_20_{i_Axi+S3_11.1100_1_3}}}&s=1000000">Three Axi S3 Relics (Mot)</option>-->
                        <option value="?m=Three+Axi+C3/G1+Relics+(Bounties)_{m_Bounty+40-60_0_3_y_{d_Stage+2,3_2_0_3_{i_Axi+C3/G1_33.0400_1_3}}_{d_Stage+4_1_0_3_{i_Axi+C3/G1_25.6800_1_1}}_{d_Stage+5_1_0_3_{i_Axi+C3/G1_38.7800_1_1}}}&s=1000000">Three Axi C3/G1 Relics (Bounties)</option>
                        <option value="?m=Three+Neo+G1+Relics+(Bounties)_{m_Bounty+30-50_0_3_y_{d_Stage+2,3_2_0_3_{i_Axi+C3/G1_15.9600_1_3}}_{d_Stage+4_1_0_3_{i_Axi+C3/G1_15.6300_1_1}}_{d_Stage+5_1_0_3_{i_Axi+C3/G1_35.7100_1_1}}}&s=1000000">Three Neo G1 Relics (Bounties)</option>
                        <option value="?m=Meso+R1+Relic+(IO+Defense)_{m_Io+Defense_0_0_y_{d_Rotation+A_2_0_5_{i_Meso+R1_12.5000_1_1}}}&s=1000000">Meso R1 Relic (Io Defense)</option>
                        <option value="?m=100+Void+Traces_{m_Quick+Fissure_0_5_y_{d_Crack+Relic_1_0_0_{i_Void+Trace_100.0000_6-30_100}}}&s=1000000">100 Void Traces</option>
                        <option value="?m=1000+Void+Traces+w/+Booster_{m_Quick+Fissure_0_5_y_{d_Crack+Relic_1_0_0_{i_Void+Trace_100.0000_12-60,2_1000}}}&s=1000000">1000 Void Traces with Booster</option>
                        <!-- Arbitration scenarios -->
                        <option value="?m=" disabled>---Arbitrations---</option>
                        <option value="?m=Arbitration+Mods+(Survival+30m)_{m_Survival_0_0_y_{d_Rotation+A_1_0_10_{i_Sharpshooter_2.0000_1_1}_{i_Vigorous+Swap_2.0000_1_1}_{i_Rolling+Guard_2.0000_1_1}_{i_Adaptation_2.0000_1_1}}_{d_Rotation+B_1_0_10_{i_Sharpshooter_2.5000_1_1}_{i_Vigorous+Swap_2.5000_1_1}_{i_Rolling+Guard_2.5000_1_1}_{i_Adaptation_2.5000_1_1}}_{d_Rotation+C_1_0_10_{i_Sharpshooter_3.5000_1_1}_{i_Vigorous+Swap_3.5000_1_1}_{i_Rolling+Guard_3.5000_1_1}_{i_Adaptation_3.5000_1_1}}}">Arbitration Mods (Survival 30 mins)</option>
                        <option value="?m=Arbitration+Mods+(Survival+1h)_{m_Survival_0_0_y_{d_Rotation+A_1_0_10_{i_Sharpshooter_2.0000_1_1}_{i_Vigorous+Swap_2.0000_1_1}_{i_Rolling+Guard_2.0000_1_1}_{i_Adaptation_2.0000_1_1}}_{d_Rotation+B_1_0_10_{i_Sharpshooter_2.5000_1_1}_{i_Vigorous+Swap_2.5000_1_1}_{i_Rolling+Guard_2.5000_1_1}_{i_Adaptation_2.5000_1_1}}_{d_Rotation+C_4_0_10_{i_Sharpshooter_3.5000_1_1}_{i_Vigorous+Swap_3.5000_1_1}_{i_Rolling+Guard_3.5000_1_1}_{i_Adaptation_3.5000_1_1}}}">Arbitration Mods (Survival 1 hour)</option>
                        <option value="?m=Arbitration+Mods+(Survival+2h)_{m_Survival_0_0_y_{d_Rotation+A_1_0_10_{i_Sharpshooter_2.0000_1_1}_{i_Vigorous+Swap_2.0000_1_1}_{i_Rolling+Guard_2.0000_1_1}_{i_Adaptation_2.0000_1_1}}_{d_Rotation+B_1_0_10_{i_Sharpshooter_2.5000_1_1}_{i_Vigorous+Swap_2.5000_1_1}_{i_Rolling+Guard_2.5000_1_1}_{i_Adaptation_2.5000_1_1}}_{d_Rotation+C_10_0_10_{i_Sharpshooter_3.5000_1_1}_{i_Vigorous+Swap_3.5000_1_1}_{i_Rolling+Guard_3.5000_1_1}_{i_Adaptation_3.5000_1_1}}}">Arbitration Mods (Survival 2 hours)</option>
                        <option value="?m=Arbitration+Mods+(Interception+1h)_{m_Interception_0_0_y_{d_Rotation+A_1_0_8_{i_Sharpshooter_2.0000_1_1}_{i_Vigorous+Swap_2.0000_1_1}_{i_Rolling+Guard_2.0000_1_1}_{i_Adaptation_2.0000_1_1}}_{d_Rotation+B_1_0_8_{i_Sharpshooter_2.5000_1_1}_{i_Vigorous+Swap_2.5000_1_1}_{i_Rolling+Guard_2.5000_1_1}_{i_Adaptation_2.5000_1_1}}_{d_Rotation+C_5_0_8_{i_Sharpshooter_3.5000_1_1}_{i_Vigorous+Swap_3.5000_1_1}_{i_Rolling+Guard_3.5000_1_1}_{i_Adaptation_3.5000_1_1}}}">Arbitration Mods (Interception 1 hour)</option>
                        <option value="?m=Aura+Forma+(Interception+1h)_{m_Interception_0_0_y_{d_Rotation+A_1_0_8_{i_Aura+Forma_1.5000_1_1}}_{d_Rotation+B_1_0_8_{i_Aura+Forma_2.0000_1_1}}_{d_Rotation+C_5_0_8_{i_Aura+Forma_2.5000_1_1}}}">Aura Forma (Interception 1 hour)</option>
                        <!-- Riven-related scenarios -->
                        <option value="?m=" disabled>---Rivens---</option>
                        <option value="?m=90+Rivens_{m_Sortie_0_0_y_{d_Complete_1_0_0_{i_Riven_27.900_1_90}}}&s=1000000">90 Rivens</option>
                        <option value="?m=Riven+for+a+Specific+Rifle_{m_Sortie_0_0_y_{d_Complete_1_0_0_{i_One+of+64+possible+Rifle+Rivens_0.1061_1_1}}}&start=start">Riven for a Specific Rifle</option>
                        <option value="?m=Decent+Melee+Riven_{r_Riven+Roll_m_{c_Decent_-1_-1_-pdddnnpppdppppn--d--p-dp-dpd--}}&s=100000">Decent Melee Riven</option>
                        <option value="?m=Basic+Damage+Gun+Riven_{r_Riven+Roll_g_{c_Damage_-1_-1_n-ddd--p-p-pppp-pndnpppd-dddnnn}}&s=100000">Basic Damage Gun Riven</option>
                        <option value="?m=Crit+or+Status+Melee+Riven_{r_Riven+Roll_m_{c_Crit_-1_-1_-pdddnnppPdppppn--d--p-dp-ddn--}_{c_Status_-1_-1_-pdddnnpdnndpppn--d--p-dp-pPp--}}&s=100000">Crit or Status Melee Riven</option>
                        <option value="?m=Status+Gun+Riven_{r_Riven+Roll_g_{c_Status_-1_-1_n-ddd--p-d-dppp-pnnnpppn-npPpnn}}&s=100000">Status Gun Riven</option>
                        <option value="?m=Crit+Gun+Riven_{r_Riven+Roll_g_{c_Crit_-1_-1_n-ddd--p-P-pppp-dndnpppd-nddnnn}}&s=100000">Crit Gun Riven</option>
                        <option value="?m=Godlike+Lanka+Riven_{r_Riven+Roll_g_{c_Hallelujah_-1_-1_n-nnn--d-p-ppdd-ddndpddn-dnnnnn}}&s=50000">Godlike Lanka Riven</option>
                        <option value="?m=Godlike+Vectis+Riven_{r_Riven+Roll_g_{c_Damage,+-Mag+Cap_-1_1_d-ddd--p-p-pppp-pddnppdd-pddddd}}&s=50000">Godlike Vectis Riven</option>
                        <option value="?m=Perfect+Rubico+Riven_{r_Riven+Roll_g_{c_Crits+for+days_-1_-1_n-ddd--d-P-Pppp-dnddpddd-dnnnnn}}&s=50000">Perfect Rubico Riven</option>
                        <option value="?m=God's+God's+Lanka+Riven_{r_Riven+Roll_g_{c_PICKY+AF_3_1_d-ddd--d-p-Pdpp-ddddPddd-dddddn}}&s=500&start=start">God's God's Lanka Riven</option>
                        <option value="?m=Riven+with+Exact+Stats_{r_Riven+Roll_g_{c_IT+HAS+TO+BE+THESE_3_1_d-ddd--d-P-Pddd-ddddPddd-dddddn}}&s=1000">Riven with Exact Stats</option>
                        <!--
                        <option value="?m=Exact+Stats+with+Locking_{r_Riven+Roll_g_{c_CC_-1_-1_d-ddd--d-P-dddd-dddddddd-dddddd}_{c_CD_-1_-1_d-ddd--d-d-Pddd-dddddddd-dddddd}_{c_MS_-1_-1_d-ddd--d-d-dddd-ddddPddd-dddddd}}_{r_Riven+Roll_g_{c_CC_-1_-1_d-ddd--d-P-dddd-dddddddd-dddddd_9}}_{r_Riven+Roll_g_{c_CD_-1_-1_d-ddd--d-L-Pddd-dddddddd-dddddd}_{c_MS_-1_-1_d-ddd--d-L-dddd-ddddPddd-dddddd}}_{r_Riven+Roll_g_{c_CD_-1_-1_d-ddd--d-L-Pddd-dddddddd-dddddd_9}}_{r_Riven+Roll_g_{c_MS_-1_-1_d-ddd--d-L-Lddd-ddddPddd-dddddd_10}}_{r_Riven+Roll_g_{c_Z_-1_-1_d-ddd--d-L-Lddd-ddddLddd-dddddn}}&s=50000">Exact Stats with Locking</option>
                        -->
                        <!-- Just some miscellaneous rough grinds -->
                        <option value="?m=" disabled>---Misc---</option>
                        <option value="?m=Shedu_{e_Symbilyst_0_0_y_{d_Kill_1_0_0_0_{i_Barrel_1.0000_1_1}_{i_Chassis_1.0000_1_1}_{i_Handle_1.0000_1_1}_{i_Receiver_1.0000_1_1}}}&s=1000000">All Shedu Parts</option>
                        <option value="?m=All+Ropalyst+Drops_{m_Ropalyst+Assassiate_0_0_y_{d_Mod+Drop_1_0_0_{i_Amalgam+Furax+Body+Count_20.0000_1_1}_{i_Amalgam+Ripkas+True+Steel_20.0000_1_1}_{i_Amalgam+Argonak+Metal+Auger_20.0000_1_1}_{i_Amalgam+Daikyu+Target+Acquired_20.0000_1_1}_{i_Amalgam+Javlok+Magazine+Warp_20.0000_1_1}}_{d_Blueprint+Drop_1_0_0_{i_Wisp_22.5600_1_1}_{i_Helmet_25.8100_1_1}_{i_Chassis_25.8100_1_1}_{i_System_25.8100_1_1}}}&s=1000000">All Ropalyst Drops</option>
                        <option value="?m=Miter_{m_Ceres+Ass_0_10_y_{d_Kill+Krill_1_0_0_{i_Barrel_16.6700_1_1}_{i_Blade_16.6700_1_1}_{i_Handle_16.6700_1_1}_{i_Chassis_16.6700_1_1}_{i_Blueprint_16.6700_1_1}}}&s=1000000">Miter</option>
                        <option value="?m=Imperator+Vandal_{m_Fomorian_0_0_y_{d_Complete_1_0_0_{i_Barrel_11.2800_1_1}_{i_Receiver_11.2800_1_1}_{i_Blueprint_38.7200_1_1}}}&s=1000000">Imperator Vandal</option>
                        <option value="?m=All+Granum+Void+Drops_{m_Granum+Void_0_0_y_{d_Rotation+C_1_0_0_0_{i_Stropha+Barrel_22.2200_1_1}_{i_Stropha+Blade_22.2200_1_1}_{i_Stahlta+Receiver_22.2200_1_1}_{i_Velox+Barrel_22.2200_1_1}_{i_Protea+Neuroptics_11.1100_1_1}}}_{m_Extended+Granum+Void_0_0_y_{d_Rotation+C_1_0_0_0_{i_Stropha+Receiver+_29.6300_1_1}_{i_Stahlta+Stock_29.6300_1_1}_{i_Velox+Receiver_29.6300_1_1}_{i_Protea+Chassis_11.1100_1_1}}}_{m_Nightmare+Granum+Void_0_0_y_{d_Rotation+C_1_0_0_0_{i_Mortuus+Shoulder+Guard+_29.6300_1_1}_{i_Stropha+Stock_29.6300_1_1}_{i_Stahlta+Barrel_29.6300_1_1}_{i_Protea+Systems_11.1100_1_1}}}&s=1000000">All Granum Void Drops</option>
                        <!-- get ready to cry -->
                        <option value="?m=Wolf+Sledge_{e_Wolf_0_0_y_{d_Kill_1_0_0_{i_Handle_13.5520_1_1}_{i_Head_13.5520_1_1}_{i_Blueprint_3.9480_1_1}_{i_Motor_3.9480_1_1}}}&s=1000000">Wolf Sledge</option>
                        <option value="?m=All+Razorback+Drops_{e_Razorback_0_0_y_{d_Kill_1_0_0_{i_Gorgon+Wraith+Blueprint_18.9700_1_1}_{i_Gorgon+Wraith+Barrel_18.9700_1_1}_{i_Gorgon+Wraith+Receiver_18.9700_1_1}_{i_Gorgon+Wraith+Stock_18.9700_1_1}_{i_Bore_5.5300_1_1}_{i_Piercing+Caliber_5.5300_1_1}_{i_Breach+Loader_5.5300_1_1}_{i_Augur+Strike_5.5300_1_1}_{i_Magma+Chamber_1.0100_1_1}_{i_Searing+Steel_1.0100_1_1}}}&s=1000000">All Razorback Drops</option>
                        <option value="?m=All+Hydrolyst+arcanes_{e_Hydrolyst_0_0_y_{d_Kill_1_0_0_0_{i_Trickery_20.2400_1_21}_{i_Velocity_16.7900_1_21}_{i_Rage_12.7400_1_21}_{i_Arachne_12.7400_1_21}_{i_Avenger_11.2400_1_21}_{i_Fury_11.2400_1_21}_{i_Grace_5.0000_1_21}_{i_Barrier_5.0000_1_21}_{i_Energize_5.0000_1_21}}}&s=500000">All Hydrolyst arcanes</option>
                        <option value="?m=All+Shadow+Stalker+Drops_{e_I+AM+YOUR+RECKONING_0_0_y_{d_Kill_1_0_0_{i_Scimitar+Engines+BP_1.0050_1_1}_{i_Broken+War+BP_2.7650_1_1}_{i_Dread+BP_37.9400_1_1}_{i_Despair+BP_2.7650_1_1}_{i_Hate+BP_2.7650_1_1}_{i_War+BP_2.7650_1_1}}}&s=1000000">All Shadow Stalker Drops</option>
                        <option value="?m=Broken+War+Parts_{e_Conculyst_0_0_y_{d_Kill_1_0_0_{i_War+Hilt+BP_0.5000_1_2}_{i_War+Blade+BP_0.5000_1_1}}}&s=1000000">Broken War Parts</option>
                        <option value="?m=Braton+and+Lato+Vandal_{m_Elite+Onslaught_0_0_y_{d_Rotation+A_2_0_5_{i_Lato+Receiver_2.0100_1_1}}_{d_Rotation+B_1_0_5_{i_Braton+Barrel_4.4200_1_1}_{i_Braton+Receiver_4.4200_1_1}_{i_Lato+BP_2.0100_1_1}}_{d_Rotation+C_1_0_5_{i_Braton+Stock_2.2100_1_1}_{i_Braton+BP_2.0100_1_1}_{i_Lato+Barrel_2.2100_1_1}}}&s=1000000">Braton and Lato Vandal</option>
                        <option value="?m=All+Kuva+Lich+Weapons_{e_Kuva+Lich_0_0_y_{d_Kill_1_0_0_1_{i_Karak_6.2500_1_1}_{i_Quartakk_6.2500_1_1}_{i_Ogris_6.2500_1_1}_{i_Kohm_6.2500_1_1}_{i_Tonkor_6.2500_1_1}_{i_Drakgoon_6.2500_1_1}_{i_Stubba_6.2500_1_1}_{i_Kraken_6.2500_1_1}_{i_Brakk_6.2500_1_1}_{i_Chakkurr_6.2500_1_1}_{i_Shildeg_6.2500_1_1}_{i_Ayanga_6.2500_1_1}_{i_Seer_6.2500_1_1}_{i_Hind_6.2500_1_1}_{i_Nukor_6.2500_1_1}_{i_Bramma_6.2500_1_1}}}&s=1000000">All Kuva Lich Weapons</option>
                        <option value="?m=Legendary+Core_{m_Sortie_0_0_y_{d_Complete_1_0_0_{i_Legendary+Core_0.1800_1_1}}}&s=1000000">Legendary Core</option>
                        <option value="?m=Xiphos_{m_Tier+1+Sabotage_0_10_y_{d_Rotation+C_1_0_0_{i_Fuselage_0.5000_1_1}}}_{m_Tier+2+Sabotage_0_10_y_{d_Rotation+C_1_0_0_{i_Engines_0.5000_1_1}}}_{m_Tier+3+Sabotage_0_10_y_{d_Rotation+C_1_0_0_{i_Avionics_0.5000_1_1}}}&s=1000000">Xiphos</option>
                        <option value="?m=All+Necramech+Mods_{m_All+3+Isolation+Vaults_0_30_y_{d_Tier+1_1_0_0_0_{i_Redirection_7.5880_1_1}_{i_Steel+Fiber_2.2110_1_1}_{i_Thrusters_0.2010_1_1}}_{d_Tier+2_1_0_0_0_{i_Reach_2.5290_1_1}_{i_Blitz_2.5290_1_1}_{i_Slipstream_2.5290_1_1}_{i_Continuity_2.2110_1_1}_{i_Seismic+Wave_0.2010_1_1}}_{d_Tier+3_3_0_0_0_{i_Fury_7.5880_1_1}_{i_Stretch_1.0600_1_1}_{i_Hydraulics_1.1060_1_1}_{i_Streamline_0.2010_1_1}}}&s=100000">All Necramech Mods</option>
                    </select>
                    <span class="tooltiptext">Pre-fill the scenario with one of these examples.</span>
                </span>
            </div>
        </div>
    </div>
</div>

<div id="errorBar">
    <div id="error">
        <div class="errorLine">Javascript not enabled.</div>
    </div>
</div>

<div class="businessDiv">
    <div class="utilGroup">
        <div class="util stopAfterDiv">
            <div class="tooltip">
                <span class="label">Stop after:</span>
                <input id="stopAfter" class="inputStopAfter" type="number" value="1000000"/>
                <span class="tooltiptextbottom">Automatically stop the simulation after the given number of runs.</span>
            </div>
        </div>
        <div id="startDiv" class="util">
            <span class="tooltip">
                <input id="startButton" class="button start" type="submit" value="Start" onClick="startRun()"/>
                <span class="tooltiptextbottom">Start the simulation.</span>
            </span>
        </div>
        <div id="stopDiv" class="utilHidden">
            <span class="tooltip">
                <input id="stopButton" class="button stop" type="submit" value="Stop" onClick="stopRun()" disabled/>
                <span class="tooltiptextbottom">Stop the simulation as soon as possible.</span>
            </span>
        </div>
        <div class="util">
            <span class="tooltip">
                <input id="clearResultsButton" class="button clear" type="submit" value="Clear"
                       onClick="stopAndclearResults()" disabled/>
                <span class="tooltiptextbottom">Clear all results.</span>
            </span>
        </div>
        <div class="util">
            <div class="popup">
                <input id="copyUrlButton" class="button urlButton popup" type="submit" value="Generate Link"
                       onClick="copyModelUrl()"/>
                <div class="popuptext" id="popupBox">
                    <input id="urlHolder" type="text" size="60" onblur="hideUrlPopup()"/>
                </div>
            </div>
        </div>
        <div class="util autoStartDiv">
            <div class="tooltip">
                <input id="copyUrlAutoStart" class="button" type="checkbox"/>
                <span class="label">Link Auto Starts</span>
                <span class="tooltiptextbottom">The link should automatically start the simulation when loaded.</span>
            </div>
        </div>
    </div>

    <div id="scenarioResults">
        <div class="trialResult"></div>
        <div class="timeResult"></div>
    </div>
</div>

<div id="scenario">
    <div class="scenarioDiv">
        <div class="modelTitle">Scenario</div>
        <div class="util">
            <span class="tooltip">
                <input id="clearButton" class="button clear" type="submit" value="Clear" onClick="clearScenario()"/>
                <span class="tooltiptext">Clears all scenario configuration.</span>
            </span>
        </div>
        <table class="fieldTable">
            <tr>
                <td class="tooltip">
                    Name:
                    <span class="tooltiptextbottom">The overall name for this collection of missions</span>
                </td>
                <td>
                    <input class="inputName" type="text"/>
                </td>
            </tr>
        </table>
    </div>
    <table class="missionTable">
        <tr class="add">
            <td>
                <span class="tooltip">
                    <input class="button addButton" id="addMission" type="submit" value="Add Mission"
                           onclick="addMission(document.getElementById('scenario'), true)"/>
                    <span class="tooltiptext">Add a mission to the scenario</span>
                </span>
                <span class="tooltip">
                    <input class="button addButton" id="addEnemy" type="submit" value="Add Enemy"
                           onclick="addEnemy(document.getElementById('scenario'), true)"/>
                    <span class="tooltiptext">Add an enemy drop to the scenario</span>
                </span>
                <span class="tooltip">
                    <input class="button addButton" id="addRivenRoll" type="submit" value="Add Riven Roll"
                           onclick="addRivenRoll(document.getElementById('scenario'), true)"/>
                    <span class="tooltiptext">Add a Riven Roll to the scenario</span>
                </span>
            </td>
        </tr>

    </table>
</div>

<div class="titleBar">
    <div class="utilGroup">
        <div class="util">
            <span class="tooltip">
                <input id="about" class="button about" type="submit" value="Help" onClick="about()"/>
                <span class="tooltiptext">Click here for lots of words</span>
            </span>
        </div>
    </div>
    <div id="lotsOfWordsContainer" style="display: none;">
        <div class="lotsOfWords">
            <h1>What is this?</h1>
            <p>
                This is an RNG simulator.
                It's designed to run a <strong>scenario</strong> with random rewards until it's successful,
                start over and repeat it over and over again, and provide a statistical analysis of how long it
                actually takes to achieve success.
            </p>
            <p>
                The purpose of this is to allow you to set your own expectations beforehand, as well as judging how
                lucky or unlucky you were after the fact. Nothing is absolutely guaranteed with RNG. However, there
                are statistically rigorous ways to set expectations and compare different scenarios, and that's what
                this page is designed to do.
            </p>
            <p>
                Most of the drop rates used in the examples are from from the official
                <a href="https://n8k6e2y6.ssl.hwcdn.net/repos/hnfvc0o3jnfvc873njb03enrf56.html">Warframe PC Drops</a>
                page.
            </p>
            <h1>Getting started</h1>
            <p>
                Select one of the pre-built scenarios from the <strong class="examplesDiv">Examples</strong> drop down
                at the top of the page.
            </p>
            <p>
                Click the <strong class="start">Start</strong> button to start the simulation.
            </p>
            <p>
                You can stop the simulation at any time by clicking the <strong class="stop">Stop</strong> button.
            </p>
            <p>
                The simulation runs the chosen scenario over and over again, up to a million times by default. While
                the simulation is running it will display a bunch of statistics. The most important ones are:
            </p>
            <ul>
                <li><strong>Average</strong>: This is the average number of missions, enemies, Riven rolls, or amount of
                    time that the scenario took to succeed. This is also known as the <strong>expected value</strong>.
                </li>
                <li><strong>90th Percentile</strong> and <strong>99th Percentile</strong>: This is the number of
                    missions, enemies, Riven rolls, or amount of time necessary in order to have a 90% or 99% chance of
                    success.
                </li>
            </ul>

            <h1>Table of Contents</h1>
            <ul id="TOC">
                <li>
                    <a href="#Running">Running</a>
                    <ul>
                        <li><a href="#Stopping">Stopping</a></li>
                        <li><a href="#Autostopping">Auto-stopping</a></li>
                    </ul>
                </li>
                <li>
                    <a href="#Results">Results</a>
                    <ul>
                        <li><a href="#Statistics">Statistics</a></li>
                        <li>
                            <a href="#DistributionChart">Distribution Chart</a>
                            <ul>
                                <li><a href="#SavingaChart">Saving a Chart</a></li>
                            </ul>
                        </li>
                        <li><a href="#StatQuery">Querying the Data</a></li>
                    </ul>
                </li>
                <li>
                    <a href="#ScenariosInDepth">Scenarios In Depth</a>
                    <ul>
                        <li>
                            <a href="#MissionScenarios">Mission Scenarios</a>
                            <ul>
                                <li><a href="#DropEventorder">Drop Event order</a></li>
                                <li><a href="#Definingthedroprate">Defining the drop rate</a></li>
                                <li>
                                    <a href="#DropCount">Drop Count</a>
                                    <ul>
                                        <li><a href="#DropCountRange">Drop Count Range</a></li>
                                    </ul>
                                </li>
                                <li>
                                    <a href="#DefiningSuccess">Defining Success</a>
                                    <ul>
                                        <li><a href="#ItemNaming">Item Naming</a></li>
                                    </ul>
                                </li>
                                <li><a href="#Time">Time</a></li>
                                <li><a href="#BailEarly">Bail Early</a></li>
                            </ul>
                        </li>
                        <li><a href="#EnemyScenarios">Enemy Scenarios</a></li>
                        <li>
                            <a href="#RivenRollScenarios">Riven Roll Scenarios</a>
                            <ul>
                                <li><a href="#RivenRoll">Riven Roll</a></li>
                                <li><a href="#RivenCriteria">Riven Criteria</a></li>
                                <li><a href="#RivenGenerationDetails">Riven Generation Details</a></li>
                            </ul>
                        </li>
                        <li><a href="#SavingTheScenario">Saving The Scenario</a></li>
                    </ul>
                </li>
                <li>
                    <a href="#NotesontheExamples">Notes on the Examples</a>
                    <ul>
                        <li><a href="#Frames">Frames</a></li>
                        <li><a href="#Mods">Mods</a></li>
                        <li><a href="#Relics">Relics</a></li>
                        <li><a href="#Arbitrations">Arbitrations</a></li>
                        <li><a href="#Rivens">Rivens</a></li>
                        <li><a href="#Misc">Misc</a></li>
                    </ul>
                </li>
                <li><a href="#ToDo">To Do</a></li>
                <li><a href="#KnownIssues">Known Issues</a></li>
            </ul>

            <h1 id="Running">Running</h1>
            <p>
                You can start the scenario at any time using the <strong class="start">Start</strong> button.
            </p>
            <p>
                Note that while the scenario is running you can't make any changes or load up another scenario.
            </p>
            <p>
                The simulation itself is all in JavaScript, and runs entirely inside your browser. You can actually
                download this HTML file and run it offline; there are no required external dependencies.
            </p>
            <h2 id="Stopping">Stopping</h2>
            <p>
                You can stop the simulation at any time using the <strong class="stop">Stop</strong> button.
            </p>
            <p>
                <strong class="warn">If you create an extremely long scenario, like adding an Item with a 0.0001% drop
                    rate, then the simulation can lock your browser tab while waiting for a single trial to finish.
                    <i>Just don't do that.</i></strong>
            </p>
            <p>
                If you manually stop the simulation, and you haven't made any changes to the scenario, then you can
                start it again and it will resume where it left off.
            </p>
            <h2 id="Autostopping">Auto-stopping</h2>
            <p>
                The <strong class="stopAfterDiv">Stop after</strong> field allows you to specify a number of trials.
            </p>
            <p>
                The simulation will automatically stop after hitting that number. By default this is one million trials,
                which seems to be a good estimate for when all the example scenarios settle in on something close to
                their true statistics.
            </p>
            <p>
                If the simulation has been automatically stopped, and you haven't made any changes to the scenario,
                then you can start it again and it will run a second set of trials up to the <strong>Stop after</strong>
                number. In other words, if your simulation reaches a million trials and you start it again, then it will
                run a million more, for a total of two million. Starting again will run up to three million, etc.
            </p>
            <p>
                Setting Stop After to 0 disables automatic stopping. The simulation will run until Stop is clicked or
                the page is closed.
            </p>

            <h1 id="Results">Results</h1>
            <p>
                While the simulation is running, and after it has completed, it will update the statistical results at
                the top of the screen. If your scenario is a Mission Scenario that includes multiple missions, then each
                Mission will also get its own results section with statistics from just that mission's runs.
            </p>
            <p>
                Each result section contains statistics for the total number of missions/enemies/Riven rolls. For a
                Mission Scenario this is a sum of all the missions that were run before success. For individual Mission
                results, this just counts the number of that mission that were run.
            </p>
            <p>
                If time data was provided in a Mission Scenario, then each results section will have a second set of
                statistics for the time each run took. Again, the Mission Scenario time result contains the sum of the
                times for all the missions run, and the individual Mission time result only counts the time spent
                running that mission.
            </p>
            <p>
                Each result section is further divided into two parts, <strong>Statistics</strong> and a <strong>Distribution
                Chart</strong>.
            </p>
            <h2 id="Statistics">Statistics</h2>
            <p>
                The table on the right shows a number of statistics for the run:
            </p>
            <ul>
                <li><strong>Average</strong>: This is the <a href="https://en.wikipedia.org/wiki/Expected_value">expected
                    average</a> of the distribution. This is the average number of mission, enemies, Riven rolls, or
                    average amount of time until success.
                </li>
                <li><strong>Median</strong>: The <a href="https://en.wikipedia.org/wiki/Median">median</a> is the
                    midpoint of the data set, otherwise known as the 50th percentile. If the distribution has a
                    non-zero skew then the median will be different from the average.
                </li>
                <li><strong>90th Percentile</strong>: The expected amount of missions/enemies/Riven rolls/time required
                    in order to have a 90% chance of success.
                </li>
                <li><strong>99th Percentile</strong>: The expected amount of missions/enemies/Riven rolls/time required
                    in order to have a 99% chance of success.
                </li>
                <li><strong>Standard Deviation</strong>: <a href="https://en.wikipedia.org/wiki/Standard_deviation">Standard
                    Deviation</a>
                    basically describes how spread out the data is from the average.
                </li>
                <li><strong>Skew</strong>: <a href="https://en.wikipedia.org/wiki/Skewness">Skew</a> describes how
                    slanted the data is towards one side or the other. A perfectly symmetric distribution has a skew
                    of zero.
                </li>
                <li><strong>Excess Kurtosis</strong>: <a href="https://en.wikipedia.org/wiki/Kurtosis">Excess
                    kurtosis</a>
                    basically describes how many extreme outliers there are compared to a normal distribution. A
                    perfectly normal distribution has an excess kurtosis of zero.
                </li>
                <li><strong>Trials</strong>: This shows the total number of trials that have been run to success.</li>
                <li>
                    <p>
                        <strong>Best Case</strong>: This is the minimum result from the current simulation run. Below
                        this statistic is shown the actual best case result, including the amount of
                        missions/enemies/Riven Rolls/time, and how many of each Item ultimately dropped it the case of
                        Mission and Enemy Scenarios, or what the actual Riven roll was in the case of Riven scenarios.
                    </p>
                    <p>
                        The Best Case also includes a count of how many separate trials had that same result.
                    </p>
                </li>
                <li><strong>Worst Case</strong>: This is the maximum result from the current simulation run. Below
                    this statistic is shown the actual worst case result, including the amount of
                    missions/enemies/Riven Rolls/time, and how many of each Item ultimately dropped it the case of
                    Mission and Enemy Scenarios, or what the actual Riven roll was in the case of Riven scenarios.
                </li>
            </ul>
            <p>
                <strong class="warn">The Best Case and Worst Case should be taken with a grain of salt. They just
                    show the best and worst case from the current simulation run. Running the simulation over again
                    with the same scenario can produce different best and worst cases.</strong>
            </p>
            <ul>
                <li><strong>Last 5 Trials</strong> (Riven Scenarios only): This shows the last five Riven rolls
                    that successfully passed the criteria.
                </li>
                <li>
                    <p>
                        <strong>Criteria met</strong> (Riven Scenarios only): If there are multiple criteria on the
                        Riven Roll, then this shows what percentage of the time each criteria was matched. 
                    </p>
                    <p>
                        Note that these may add to more than 100% if the criteria are not mutually exclusive.
                    </p>
                </li>
                <li>
                    <p>
                        <strong>Riven Probability</strong> (Riven Scenarios only): This shows the probability of rolling
                        the Riven criteria given the data collected so far.
                    </p>
                    <p>
                        Riven Rolls always boil down to a simple Negative Binomial Distribution, so this is simply
                        1 / Average.
                    </p>
                </li>
            </ul>

            <h2 id="DistributionChart">Distribution Chart</h2>
            <p>
                The chart on the left shows a graphical view of the results. There are two possible views:
            </p>
            <ul>
                <li>
                    <p>
                        <strong>Probability Density</strong>:
                        This shows the <a href="https://en.wikipedia.org/wiki/Probability_distribution">probability
                        distribution</a>.
                        The X axis represents possible results, and the height of the chart shows the relative frequency
                        of
                        that result.
                    </p>
                    <p>
                        Most of the results tend to cluster on the left side of this chart, below the average,
                        with a long tail of unlikely results extending very far to the right. The right edge of the
                        chart cuts off at the 99.9th Percentile, but the <strong>Worst Case</strong> result shows you
                        just how far it could extend if it was drawn out in full.
                    </p>
                </li>
                <li>
                    <p>
                        <strong>Cumulative Probability</strong>:
                        This shows the <a href="https://en.wikipedia.org/wiki/Cumulative_distribution_function">cumulative
                        probability distribution</a>. The X axis represents possible results, and the height of the
                        chart
                        shows the probability of getting that result or better, from 0% to 100%.
                    </p>
                    <p>
                        In this chart the value increases and approaches 100% as it goes to the right. Like the other
                        chart, this cuts off at the 99.9th Percentile to save space.
                    </p>
                </li>
            </ul>
            <p>
                You can switch between these two views using the buttons above the chart.
            </p>
            <p>
                In both cases, there is a highlighted vertical line which shows where the average falls on the chart.
            </p>
            <p>
                The distribution of results basically follows a
                <a href="https://en.wikipedia.org/wiki/Negative_binomial_distribution">Negative Binomial
                    Distribution</a>, with Drop Events representing separate
                <a href="https://en.wikipedia.org/wiki/Bernoulli_trial">Bernoulli Trials</a>. If the scenario only
                contains one Drop Event with one Item, then it's exactly equal to a Negative Binomial Distribution, and
                you can actually calculate exact values for Average, 90th percentile, etc. However, with more than one
                Item or Drop Event things get complicated to the point where it's easier to run a simulation than it is
                to try and calculate the exact statistics.
            </p>

            <h3 id="SavingaChart">Saving a Chart</h3>
            <p>
                Most browsers should allow you to right-click on a chart and save it directly. However, if you simply
                click on a chart then it will be converted in-place to a PNG image, which you should definitely be
                able to save.
            </p>

            <h2 id="StatQuery">Querying the Data</h2>
            <p>
                Underneath the chart is a <strong class="button query">Query</strong> button.  Clicking this button
                will display two fields:
            </p>
            <ul>
                <li><strong>Result</strong>: A specific result, for example, how many runs you personally took to succeed at the chosen secnario</li>
                <li><strong>Percentile</strong>: The probability of achieving the given result or better, as a percentage</li>
            </ul>
            <p>
                If you enter a value in either of these fields and hit enter, it will calculate the other value.
                For example, if you have a particular result and want to know the percentile then you can fill in
                <strong>Result</strong> and let it calculate Precentile.  Or, if you want to know a percentile other
                than the provided 50th, 90th, and 99th, then you can fill in <strong>Percentile</strong> and let it
                calculate the corresponding result.
            </p>

            <h1 id="ScenariosInDepth">Scenarios In Depth</h1>
            <p>
                There are three types of Scenarios:
            </p>
            <ul>
                <li><strong>Mission Scenario</strong>: These scenarios are about running a mission or series of
                    missions. These usually have some time duration associated with each mission.
                </li>
                <li><strong>Enemy Scenario</strong>: These scenarios are about finding and killing a particular type of
                    enemy.
                </li>
                <li><strong>Riven Scenario</strong>: These scenarios are about rolling a Riven mod until its stats
                    meet particular criteria
                </li>
            </ul>

            <h2 id="MissionScenarios">Mission Scenarios</h2>
            <p>
                A <strong>Mission Scenario</strong> is built up in three layers:
            </p>
            <ol>
                <li>The Scenario contains one or more <strong>Missions</strong>. A Mission represents something that can
                    be repeated as many times as necessary, like a Cetus Bounty or a Sabotage mission.
                </li>
                <li>A Mission contains one or more <strong>Drop Events</strong>. A Drop Event represents something that
                    triggers an RNG-based reward, like completing a survival rotation or finding all three Sabotage
                    Caches.
                </li>
                <li>A Drop Event contains one or more <strong>Items</strong>. An Item represents an individual object
                    that the Drop Event can reward, like a blueprint or a mod.
                </li>
            </ol>

            <h3 id="DropEventorder">Drop Event order</h3>
            <p>
                Each time a mission is run, each of its Drop Events is run in the order in which they are listed. A
                Drop Event can be repeated in the same mission by setting <strong>Events Per Mission</strong>. This is
                for when the Drop Event is something like an A Rotation that repeats twice per Mission.
            </p>
            <p>
                The order in which Drop Events are listed should be the order in which they actually occur during the
                mission. See <a href="#BailEarly">Bail Early</a> below.
            </p>

            <h3 id="Definingthedroprate">Defining the drop rate(s)</h3>
            <p>
                A <strong>drop rate</strong> is defined for each individual Item. This represents the probability of
                that Item being rewarded by the Drop Event containing it. The drop rate is a percentage, greater than
                0% and less than 100%.
            </p>
            <p>
                The sum of the drop rates for all the Items under a single Drop Event cannot add up to more than 100%.
                They can, however, add up to less than 100%. When the drop rates under a Drop Event add up to less than
                100% then that means the Drop Event has a chance of not dropping anything we're interested it.
            </p>

            <h3 id="DropCount">Drop Count</h3>
            <p>
                For each Item, <strong>Drop Count</strong> is the number of that Item that drops from a single Drop
                Event.
            </p>
            <p>
                Most of the time you'll want to leave this at <strong>1</strong>. For the vast majority of drops we
                care about analyzing, they drop one at a time.
            </p>
            <h4 id="DropCountRange">Drop Count Range</h4>
            <p>
                There are a couple of "resource"-like items that drop many at a time, like Void Traces and
                Kuva. For this, you can actually specific a <strong>range</strong> in the Drop Count field. Range is
                specified as a minimum count and a maximum count, separate by a dash, like <strong>6-30</strong> or
                <strong>550-700</strong>.  Any number between the minimum and maximum, inclusive, has an equal chance
                of occurring.
            </p>
            <p>
                You can tweak this by adding a comma and then an increment.  This causes it to choose only numbers in
                that increment between the minimum and maximum, rather than every possible number.  For example,
                <strong>12-60,2</strong> causes it to pick only even numbers between 12 and 60, and
                <strong>500-750,10</strong> causes it to pick only multiples of 10 between 500 and 750.
                In most cases this only makes a small difference, but it does make a difference.
            </p>

            <h3 id="DefiningSuccess">Defining Success</h3>
            <p>
                An individual <strong>Item</strong> defines a <strong>Number Required</strong>. This is the total
                amount of that Item that must drop before that Item is considered successful. It's 1 by default, but
                you can make it higher to simulate how long it would take to get that many multiples of an item, or
                if the Items' Drop Count is something other than 1.
            </p>
            <p>
                There are some more advanced success requirements you can set at the Drop Event and Mission levels. You
                probably won't have to mess with these.
            </p>
            <ul>
                <li>By default, if a <strong>Drop Event</strong>'s <strong>Items Required</strong> field is left at
                    zero, then we require that all of its Items under that Drop Event reach their required numbers.
                    You can make Required Items greater than zero, in which case only that many Items have to be
                    successful. Note that this is a count of unique Items, and does not count multiples of a single
                    Item. The value of Required Items cannot be larger than the number of unique Items in the Drop
                    Event.
                </li>
                <li>By default, if a <strong>Mission</strong>'s <strong>Drop Events Required</strong> field is left at
                    zero, then then we require that all of the Drop Events under that Mission reach their required
                    Items. Like Required Items, You can make Required Drop Events greater than zero, in which case
                    only that many Drop Events have to be successful. Note that this is a count of Drop Events, not
                    individual Items. The value of Required Drop Events cannot be larger than the number of Drop Events
                    in the Mission.
                </li>
            </ul>
            <h4 id="ItemNaming">Item Naming</h4>
            <p>
                A Name is assigned to each Item, uniquely identifying it. A single Drop Event can't contain two Items
                with the same name. However the same Item name can appear in more than one Drop Event, and in more
                than one Mission. When this happens, an Item dropping in one Drop Event counts towards every Item in
                the Scenario with the same name.
            </p>
            <h3 id="Time">Time</h3>
            <p>
                In addition to tracking the total number of missions it takes to get success, we can also assign a time
                duration to each mission and/or drop event. The time is given as a <strong>whole number of
                minutes</strong>.
            </p>
            <ul>
                <li><strong>Mission</strong> time is used when a mission has some set amount of time it takes. This is
                    the base amount of time a mission takes regardless of drop events/rotations.
                </li>
                <li><strong>Drop Event</strong> time is used when a drop event itself has some set amount of time it
                    takes to trigger, like a survival rotation. If a drop event repeats more than once then its time
                    will be multiplied by how many times it occurred during that mission.
                </li>
            </ul>
            <p>
                To determine the total amount of time a mission takes the base mission time, if any, is added to the
                times for each drop event that occurred, if any.
            </p>
            <p>
                Some missions, like Survival and Onslaught, have a set amount of time they and their drop
                events/rotations will take. With other mission types you have come up with an estimate.
            </p>
            <p>
                In the examples at the top of this page, I'm using the following time estimates:
            </p>
            <ul>
                <li><strong>Exterminate</strong>: 5 minutes</li>
                <li><strong>Capture</strong>: 5 minutes</li>
                <li><strong>Assassinate</strong>: 10 minutes.
                </li>
                <li>Finding all three supply caches during <strong>Sabotage</strong> or <strong>Lua Crossfire</strong>:
                    10 minutes
                </li>
                <li><strong>Spy</strong> if you're bad at Spy: 10 minutes</li>
                <li>Cetus <strong>bounty stage</strong>: 3 minutes</li>
                <li>Cetus <strong>Incursion</strong>, waiting for it to appear and then doing it: about 5 minutes</li>
                <li><strong>Infested Salvage</strong>: 20 minutes to rotation C</li>
                <li><strong>Onslaught/Elite Onslaught</strong>: 20 minutes to rotation C</li>
            </ul>
            <h3 id="BailEarly">Bail Early</h3>
            <p>
                If there are multiple Drop Events in a Mission, then it's possible for the later Drop Events to succeed
                during the run before the earlier ones. If there's a point in the mission after which all the Drop
                Events have already been successful, then we can <strong>bail early</strong>, ending the mission there
                and saving time.
            </p>
            <p>
                This behavior is enabled by default in order to give us the shortest possible time. You can force a
                particular mission not to bail early by unchecking the Bail Early checkbox under the mission.
            </p>
            <h3 id="PreventConsecutiveDupes">Prevented Consecutive Repeats</h3>
            <p>
                In some special cases (Kuva Liches) they have added the ability to prevent consecutive duplicate rewards.
                Setting this to 1 will enable that behavior in the simulation.
            </p>
            <p>
                You can also set this value to more than 1, if you want to prevent duplicate rewards going back the given
                number of consecutive drops.  Note that Prevented Consecutive Repeats must be less than the number
                of items in the drop.
            </p>
            <h2 id="EnemyScenarios">Enemy Scenarios</h2>
            <p>
                An Enemy Scenario is basically a simplified Mission Scenario, where the mission and drop event
                are just finding an enemy and killing it.
            </p>
            <p>
                An Enemy Scenario just has single Enemy to kill, and a single Item list under the Enemy. You still
                have access to <strong>Required Items</strong> to control how many of the Item drops need to succeed for
                the scenario to succeed, but there is no time duration or any other settings.
            </p>

            <h2 id="RivenRollScenarios">Riven Roll Scenarios</h2>
            <p>
                A <strong>Riven Roll Scenario</strong> tracks how many times a Riven needs to be rolled in
                order to meet certain stat criteria. A Riven-based scenario is built up in two layers:
            </p>
            <ol>
                <li>A Scenario contains one <strong>Riven Roll</strong>. A Riven Roll represents a single
                    Riven Mod that can be rolled as many times as necessary.
                </li>
                <li>A Riven Roll contains one or more <strong>Riven Criteria</strong>. A Criteria represents a list of
                    stats that are required or wanted as either positive or negative stats on the Riven mod.
                </li>
            </ol>
            <h3 id="RivenRoll">Riven Roll</h3>
            <p>
                The only configuration for the <strong>Riven Roll</strong> is what kind of Riven it is,
                <strong>Gun</strong> or <strong>Melee</strong>. This determines the list of stats to choose from.
            </p>
            <h3 id="RivenCriteria">Riven Criteria</h3>
            <p>
                The <strong>Riven Criteria</strong> contains a few configuration fields followed by the full list of
                possible stats for the Riven type.
            </p>
            <p>
                <strong>Required Positives</strong> and <strong>Required Negatives</strong> can be used if you want a
                specific number of positive or negative stats.  For the positive stats, you can require 2, 3, or accept
                both 2 or 3.  For the negative stats, you can require 0, 1, or accept both 0 or 1.
            </p>
            <p>
                For the stats themselves, they are listed in alphabetical order. For each one, one of four options is
                available:
            </p>
            <ul>
                <!--
                <li>
                    <p>
                        <strong class="checkmarkHelp positiveLockHelp">L</strong>: <strong>Locked Positive</strong>
                    </p>
                    <p>
                        (Experimental)
                    </p>
                </li>
                -->
                <li>
                    <p>
                        <strong class="checkmarkHelp positiveReqHelp">++</strong>: <strong>Required Positive</strong>
                    </p>
                    <p>
                        This marks a stat that's <i>required</i> to be among the Riven's positive stats. If this is
                        selected for three stats then the Riven is automatically required to have three positive stats,
                        and
                        all three of the marked stats must be present.
                    </p>
                    <p>
                        You cannot select more than three required positive stats.
                    </p>
                </li>
                <li>
                    <p>
                        <strong class="checkmarkHelp positiveHelp">+</strong>: <strong>Wanted Positive</strong>.
                    </p>
                    <p>
                        This marks a stat that you <i>want</i> to be used in the Riven's positive stats. You can mark
                        as many stats as you like this way; the only requirement is that the Riven's positive stats
                        come from the set of Wanted Positives.
                    </p>
                    <p>
                        If there are less than three total Required and Wanted Positives, then the remaining positive
                        stats in the Riven can come from the Don't Care set.
                    </p>
                </li>
                <li>
                    <p>
                        <strong class="checkmarkHelp negativeHelp">+</strong>: <strong>Wanted Negative</strong>.
                    </p>
                    <p>
                        This marks a stat that you <i>want</i> to be used as the Riven's negative stat. You can mark
                        as many stats as you like this way; the only requirement is that the Riven's negative stat
                        comes from the set of Wanted Negatives.
                    </p>
                    <p>
                        If there are no Wanted Negatives, then the Riven's negative stat can come from the Don't
                        Want set, unless Required Negatives is set to zero.
                    </p>
                    <p>
                        If there is only one Wanted Negative marked, then the negative stat on the Riven, if present,
                        must be that stat.
                    </p>
                </li>
                <!--
                <li>
                    <p>
                        <strong class="checkmarkHelp negativeLockHelp">L</strong>: <strong>Locked Negative</strong>.
                    </p>
                    <p>
                        (Experimental)
                    </p>
                </li>
                -->
                <li>
                    <p>
                        <strong class="checkmarkHelp dontcareHelp">?</strong>: <strong>Don't Care</strong>
                    </p>
                    <p>
                        The Don't Care category is everything else. If there aren't enough Wanted/Required Positive
                        stats or Wanted Negative stats to fill out a Riven, then the remaining stats can come from the
                        Don't Care list. Otherwise, stats marked as Don't Care will not appear in accepted Rivens at
                        all.
                    </p>
                </li>
            </ul>
            <p>
                The Riven Criteria is only concerned with which stats appear on the Riven, not their actual numeric
                values.
            </p>
            <h3 id="RivenGenerationDetails">Riven Generation Details</h3>
            <p>
                I've had to make a few assumptions about how Riven stats are generated, because the details are not
                published like other drop rates.
            </p>
            <ul>
                <li>
                    <strong>Two vs Three Positive Stats</strong>: I'm assuming that the choice between two or three
                    positive stats is just a 50/50 chance. My own my own sampling of about a hundred rolls on various
                    Rivens comes close enough to 50/50 to make this likely.
                </li>
                <li>
                    <strong>Zero vs One Negative Stat</strong>: I'm also assuming that the choice between zero or one
                    negative stats is a 50/50 chance. Again, this is backed up by my experience.
                </li>
                <li>
                    <strong>No correlation</strong> between the number of positive stats and the number of negative
                    stats. I'm assuming that all four combinations of 2/3 positives and 0/1 negative are equally
                    likely.
                </li>
                <li>
                    <strong>Stat probability</strong>: I'm assuming that, on each roll, all applicable stats have the
                    same
                    probability of being chosen.
                </li>
                <li>
                    <strong>Negative Stat Exclusions</strong>: I'm assuming that the following stats never appear as
                    negative
                    stats:
                    <ul>
                        <li>Cold Damage</li>
                        <li>Electric Damage</li>
                        <li>Heat Damage</li>
                        <li>Toxin Damage</li>
                        <li>Punch Through (This one has been confirmed)</li>
                        <li>Combo Duration</li>
                    </ul>
                </li>
            </ul>

            <h1 id="SavingTheScenario">Saving The Scenario</h1>
            <p>
                Use the <strong class="urlButton">Generate Link</strong> button to build a link to the current Scenario.
            </p>
            <p>
                This link can be copied and shared. Opening it will pre-fill the page exactly how it currently appears.
            </p>
            <p>
                If you check the <strong class="autoStartDiv">Auto Start</strong> checkbox then the link will
                automatically start the Scenario when opened.
            </p>

            <h1 id="NotesontheExamples">Notes on the Examples</h1>

            <h2 id="Frames">Frames</h2>
            <p>
                The frame scenarios are listed roughly in order of how long each one takes.
            </p>
            <p>
                Just guessing, but I think the line between being faster to farm the frame directly and being faster to
                run Tridolons, sell Arcanes for Plat, and buy the frame, is somewhere between Nidus and Ivara. I still
                recommend spending some time farming Ivara, if only for the Spy practice. However, Khora is firmly on
                the plat side of that line, with very little else to get from that mission besides maybe ranking up
                other warframes.
            </p>
            <table class="notes">
                <tr>
                    <td>
                        <a href="?m=Standard+Boss+Frame_{m_Assassinate_0_10_y_{d_Complete_1_0_0_{i_Helmet_38.7200_1_1}_{i_Chassis_38.7200_1_1}_{i_Systems_22.5600_1_1}}}&start=start">Standard
                            Boss Frame</a>:
                    </td>
                    <td>
                        There's a lot of variance in how long the various assassination missions take, so I just guessed
                        an average of 10 minutes.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Ash_{e_Grineer+Manic_0_0_y_{d_Kill_1_0_0_{i_Chassis_12.7776_1_1}_{i_Helmet_12.7776_1_1}_{i_Systems_7.4480_1_1}}}&start=start">Ash</a>:
                    </td>
                    <td>
                        This is not something you can actively farm, but it's interesting that it doesn't actually take
                        that many Manics to get.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Gara_{m_Bounty+5-15_0_0_y_{d_Stage+2_1_0_6_{i_Chassis_7.5200_1_1}}_{d_Stage+3_1_0_3_{i_Chassis_30.5600_1_1}}}_{m_Bounty+10-20_0_0_y_{d_Stage+2_1_0_6_{i_Systems_9.5200_1_1}}_{d_Stage+3_1_0_3_{i_Systems_21.8200_1_1}}}_{m_Bounty+20-30_0_0_y_{d_Stage+3_1_0_9_{i_Helmet_8.4200_1_1}}_{d_Stage+4_1_0_3_{i_Helmet_20.5100_1_1}}}&start=start">Gara</a>:
                    </td>
                    <td>
                        This is an example where the same Item can drop from multiple Drop Events, since each Gara part
                        drops from multiple bounty stages with a different drop rate in each stage.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Garuda_{m_Bounty+5-15_0_0_y_{d_Stage+2_1_0_6_{i_Chassis_7.5200_1_1}}_{d_Stage+3_1_0_3_{i_Chassis_30.5600_1_1}}}_{m_Bounty+10-20_0_0_y_{d_Stage+2_1_0_6_{i_Systems_7.4100_1_1}}_{d_Stage+3_1_0_3_{i_Systems_22.2200_1_1}}}_{m_Bounty+20-30_0_0_y_{d_Stage+3_1_0_9_{i_Helmet_12.5000_1_1}}_{d_Stage+4_1_0_3_{i_Helmet_25.0000_1_1}}}&s=1000000&start=start">Garuda</a>:
                    </td>
                    <td>
                        Garuda's grind is comparabe to Gara, at least for getting the blueprints.  Getting the materials
                        is another matter entirely.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Protea_{m_Granum+Void_0_5_y_{d_Rotation+C_1_0_0_0_{i_Protea+Neuroptics_11.1100_1_1}}}_{m_Extended+Granum+Void_0_5_y_{d_Rotation+C_1_0_0_0_{i_Protea+Chassis_11.1100_1_1}}}_{m_Nightmare+Granum+Void_0_5_y_{d_Rotation+C_1_0_0_0_{i_Protea+Systems_11.1100_1_1}}}&start=start">Protea</a>:
                    </td>
                    <td>
                        Each part takes nine tries on average, but there's going to be a lot of variance with the time
                        depending on exactly which Corpus Ship missions you choose.  I'm guessing five minutes for each
                        run assuming you pick a capture or exterminate but have to wait for the Treasurer to appear and
                        drop a coin each time.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Octavia_{m_ODS_0_0_y_{d_Rotation+C_1_0_20_{i_Helmet_22.5600_1_1}}}_{m_Lua+Crossfire+With+Caches,+Music+Room_0_5_y_{d_Music+Room+(guessing+at+spawn+rate)_1_1_0_{i_Chassis_25.0000_1_1}}_{d_Cache+A_1_0_5_{i_Systems_22.5600_1_1}}}&start=start">Octavia</a>:
                    </td>
                    <td>
                        <p>
                            Getting the Neuroptics from ODS is pretty straightforward. For the other two parts I
                            combined
                            the Lua cache hunt with the Music Room hunt, as you'll probably find the latter by accident
                            while looking for caches. I took a wild guess that the Music Room spawn rate is about 25%.
                        </p>
                        <p>
                            The scenario splits up the second mission into five minutes finding the caches and five
                            minutes just doing the mission. So if the Systems drops from the caches first then it bails
                            early and only spends five minutes running the mission and looking for the music room.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Revenant_{m_Bounty+20-40_0_3_y_{d_Stage+2_1_0_3_{i_Systems_8.8700_1_1}}_{d_Stage+3_1_0_3_{i_Systems_8.6833_1_1}}_{d_Stage+4_1_0_3_{i_Systems_20.1700_1_1}}}_{m_Bounty+30-50_0_3_y_{d_Stage+2,3_2_0_3_{i_Chassis_8.4500_1_1}}_{d_Stage+4_1_0_3_{i_Chassis_8.2733_1_1}}_{d_Stage+5_1_0_3_{i_Chassis_19.3667_1_1}}}_{m_Bounty+40-60_0_9_y_{d_Stage+4_1_0_3_{i_Helmet_6.7600_1_1}}_{d_Stage+5_1_0_3_{i_Helmet_10.0200_1_1}}}&start=start">Revenant</a>:
                    </td>
                    <td>
                        Like Gara, Revanant's parts drop from multiple bounty stages with different drop rates in each
                        one. Revanant takes a little longer than Gara on average because of the longer bounties and the
                        rare status of the third part.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Revenant+(no+bail+early)_{m_Bounty+20-40_0_3_n_{d_Stage+2_1_0_3_{i_Systems_8.8700_1_1}}_{d_Stage+3_1_0_3_{i_Systems_8.6833_1_1}}_{d_Stage+4_1_0_3_{i_Systems_20.1700_1_1}}}_{m_Bounty+30-50_0_3_n_{d_Stage+2,3_2_0_3_{i_Chassis_8.4500_1_1}}_{d_Stage+4_1_0_3_{i_Chassis_8.2733_1_1}}_{d_Stage+5_1_0_3_{i_Chassis_19.3667_1_1}}}_{m_Bounty+40-60_0_9_n_{d_Stage+4_1_0_3_{i_Helmet_6.7600_1_1}}_{d_Stage+5_1_0_3_{i_Helmet_10.0200_1_1}}}&start=start">Revenant
                            (no bail early)</a>:
                    </td>
                    <td>
                        The Gara and Revanant scenarios above both enable Bail Early to cut down on time a little bit.
                        This is an example of what happens when you disable Bail Early on these kinds of multi-rotation
                        missions. In this case, bailing early seems to save about 10-15 minutes on the average, from
                        2.8 hours down to 2.6. Also, not bailing early makes the probability density chart for the total
                        time look totally cool.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Gauss_{m_Kelpie+-+8+rounds_0_10_y_{d_Rotation+C_6_0_5_0_{i_Chassis_7.8400_1_1}_{i_Neuroptics_7.8400_1_1}_{i_Systems_7.8400_1_1}}}&start=start">Gauss - 8 rounds</a>:
                    </td>
                    <td>
                        Doing eight rounds of disruption gives you three times as many rotation Cs as other rotations,
                        bringing this grind down to manageable
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Harrow_{m_Pago_0_5_y_{d_Rotation+C_1_0_0_0_{i_Neuroptics_11.2800_1_1}}}_{m_Mid-level+Defection_0_0_y_{d_Rotation+B_1_0_15_0_{i_Systems_2.0100_1_1}}_{d_Rotation+C_1_0_5_0_{i_Systems_11.2800_1_1}}}&start=start">Harrow</a>:
                    </td>
                    <td>
                        The Chassis is basically a given if you do any amount of relic cracking, and the Neuroptics isn't
                        bad if you're decent at spy or can get a friend.  The real killer with Harrow is the Systems,
                        with an expected 3 hours in everyone's least favorite game mode.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Equinox_{m_Uranus+Assassinate_0_10_y_{d_Kill+Tyl_1_0_0_{i_Night+Aspect_11.2800_1_1}_{i_Night+Chassis_12.9100_1_1}_{i_Night+Systems_12.9100_1_1}_{i_Night+Helmet_12.9100_1_1}_{i_Day+Aspect_11.2800_1_1}_{i_Day+Chassis_12.9100_1_1}_{i_Day+Systems_12.9100_1_1}_{i_Day+Helmet_12.9100_1_1}}}&start=start">Equinox</a>:
                    </td>
                    <td>
                        Everyone's favorite example of a heavy grind is at most the fourth worst.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Gauss_{m_Kelpie+-+4+rounds_0_10_y_{d_Rotation+C_2_0_5_0_{i_Chassis_7.8400_1_1}_{i_Neuroptics_7.8400_1_1}_{i_Systems_7.8400_1_1}}}&start=start">Gauss - 4 rounds</a>:
                    </td>
                    <td>
                        If you do a minimal four rounds on each disruption mission then you only get 50% rotation Cs,
                        making your expected grind time for Gauss slightly worse than Equinox.  So do more than four.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Nidus_{m_Infested+Salvage_0_0_y_{d_Rotation+C_1_0_20_{i_Systems_14.2900_1_1}_{i_Helmet_14.2900_1_1}_{i_Chassis_14.2900_1_1}}}&start=start">Nidus</a>:
                    </td>
                    <td>
                        It varies how long it actually takes to hit rotation C on infested Salvage, depending on
                        how on top of it your team is. I gave it a nice round 20 minutes.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Ivara_{m_Tier+1+Spy_0_10_y_{d_Rotation+C_1_0_0_{i_Systems_9.0900_1_1}}}_{m_Tier+2+Spy_0_10_y_{d_Rotation+C_1_0_0_{i_Chassis_5.6400_1_1}}}_{m_Tier+3+Spy_0_10_y_{d_Rotation+C_1_0_0_{i_Helmet_7.5200_1_1}_{i_BP_7.5200_1_1}}}&start=start">Ivara</a>:
                    </td>
                    <td>
                        I'm estimating 10 minutes for a Spy mission but if you're good at Spy, or have a friend who's
                        good at Spy, then they can be cut down to five minutes. However, even with the ten minute
                        estimate Ivara is still second place.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Khora_{m_Onslaught_0_0_y_{d_Rotation+A_2_0_5_{i_Chassis_8.3300_1_1}}_{d_Rotation+B_1_0_5_{i_Helmet_7.6900_1_1}}_{d_Rotation+C_1_0_5_{i_Systems_5.6400_1_1}_{i_BP_5.6400_1_1}}}&start=start">Khora</a>:
                    </td>
                    <td>
                        20 minutes to get to Rotation C is somewhat of an underestimate, but good enough. Disabling
                        early bailing adds about 20 minutes to the expected average, bringing it close to an even ten
                        hours.
                    </td>
                </tr>
            </table>
            <h2 id="Mods">Mods</h2>
            <p>
                There are a ton of very low drop rate mods. A lot of them drop from common enemies you'll run into
                thousands of times just through normal play, which somewhat lessens the impact of the low drop rate.
                Most of the others are Melee Stance mods.
            </p>
            <p>
                The nice thing about mods is that trading is always available as a check on bad luck. On a long enough
                time line your luck will even out, and if you're unlucky with one mod then you might have already gotten
                lucky with a different rare mod and have an extra copy to trade. This is especially true with mod
                sets that all drop from the same place, like Corrupted Mods, Kela de Thaym's mods, Razorback, etc.
                By the time you hit the expected average number of runs you'll probably have enough to trade for
                what you're missing.
            </p>
            <table class="notes">
                <tr>
                    <td>
                        <a href="?m=Argon+Scope_{e_Torment_0_0_y_{d_Kill_1_0_0_{i_Argon+Scope_4.0400_1_1}}}&start=start">
                            Argon Scope</a>:
                    </td>
                    <td>
                        This one wouldn't be that bad if it wasn't time limited and only once a year or so.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=All+Mods+From+An+Acolyte_{e_Acolyte_0_0_y_{d_Kill_1_0_0_{i_Argon+Scope_4.0400_1_1}_{i_Hydraulic+Crosshairs_51.5200_1_1}_{i_Laser+Sight_22.2200_1_1}_{i_Blood+Rush_22.2200_1_1}}}&start=start">
                            All Mods From An Acolyte</a>:
                    </td>
                    <td>
                        It takes only slightly longer on average to get all four mods from an Acolyte.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Fetch_{e_Orb+Vallis+Hyena_0_0_y_{d_Kill_1_0_0_{i_Fetch_1.3790_1_1}}}&start=start">
                            Fetch</a>:
                    </td>
                    <td>
                        Fetch seems pretty benign, but no idea what the spawn rate of Orb Vallis Hyenas is.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Four+Riders_{e_Grineer+Manic_0_0_y_{d_Kill_1_0_0_{i_Four+Riders_0.3350_1_1}}}&start=start">
                            Four Riders</a>:
                    </td>
                    <td>
                        You have to kill a heck of a lot of Manics on average to get this stance mod.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Vengeful+Revenant_{e_Conculyst_0_0_y_{d_Kill_1_0_0_{i_Vengeful+Revenant_0.4170_1_1}}}&start=start">
                            Vengeful Revenant</a>:
                    </td>
                    <td>
                        This shows why loot frames like Ivara and Nekros are almost mandatory when farming Conculysts.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=m=Bullet+Dance_{m_Marduk_0_0_y_{d_Rotation+C_1_0_0_{i_Bullet+Dance_4.4200_1_1}}}&start=start">
                            Bullet Dance</a>:
                    </td>
                    <td>
                        You have to find all three caches just to get a chance.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Tempo+Royale+(Bursa)_{e_Isolator+Bursa_0_0_y_{d_Kill_1_0_0_{i_Tempo+Royale_0.0603_1_1}}}&start=start">
                            Tempo Royale (Bursa)</a>:
                    </td>
                    <td>
                        Is it faster to wait for Baro to bring this?
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Tempo+Royale+(Incursion)_{m_Plains+Incursion_0_5_y_{d_Rotation+A_1_0_0_{i_Tempo+Royale_1.0100_1_1}}}&start=start">
                            Tempo Royale (Incursion)</a>:
                    </td>
                    <td>
                        ...Yes.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Condition+Overload_{e_Drekar+Butcher_0_0_y_{d_Kill_1_0_0_{i_Condition+Overload_0.0201_1_1}}}&s=100000&start=start">
                            Condition Overload</a>:
                    </td>
                    <td>
                        The simulation gets pretty slow when you start getting into the really rare drops like this.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Guardian+Derision_{e_Prod+Crewman_0_0_y_{d_Kill_1_0_0_{i_Guardian+Derision_0.0150_1_1}}}&start=start">
                            Guardian Derision</a>:
                    </td>
                    <td>
                        I <i>still</i> don't have this one.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Full+Hunter+Set_{m_Level+15-25+Ghoul+Bounty_0_0_y_{d_Stage+1_1_0_3_{i_Adrenaline_33.3300_1_1}}_{d_Stage+2,+3_2_0_3_{i_Adrenaline_11.7400_1_1}_{i_Munitions_9.3900_1_1}}_{d_Stage+4_1_0_3_{i_Munitions_11.9000_1_1}_{i_Track_11.9000_1_1}}}_{m_Level+40-50+Ghoul+Bounty_0_0_y_{d_Stage+1_1_0_3_{i_Recovery_33.3300_1_1}}_{d_Stage+2,+3_2_0_3_{i_Recovery_11.7400_1_1}_{i_Synergy_9.3900_1_1}}_{d_Stage+4_1_0_3_{i_Recovery_10.2900_1_1}_{i_Synergy_8.2300_1_1}_{i_Command_8.2300_1_1}}_{d_Stage+5_1_0_3_{i_Synergy_11.9000_1_1}_{i_Command_11.9000_1_1}}}&start=start">
                            Full Hunter Set (Ghouls)</a>:
                    </td>
                    <td>
                        A full set of these is going to take a little bit of time, if you can catch a Ghoul event.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Full+Hunter+Set+(Plague+Star)_{m_Plague+Star_0_15_y_{d_Kill+Hemocyte_4_0_0_{i_Hunter+Command_10.5300_1_1}_{i_Hunter+Recovery_28.9500_1_1}_{i_Hunter+Synergy_10.5300_1_1}_{i_Hunter+Munitions_10.5300_1_1}_{i_Hunter+Track_10.5300_1_1}_{i_Hunter+Adrenaline_28.9500_1_1}}}&start=start">
                            Full Hunter Set (Plague Star)</a>:
                    </td>
                    <td>
                        It's much if you can manage to catch a Plague Star event, assuming you can kill four Hemocytes
                        pretty quickly.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Full+Synth/Mecha/Tek+Set_{m_Bounty+10-30_0_0_y_{d_Stage+3_1_0_3_{i_Synth+Charge_22.2200_1_1}}}_{m_Bounty+20-40_0_0_y_{d_Stage+4_1_0_3_{i_Synth+Deconstruct_25.0000_1_1}}}_{m_Bounty+30-50_0_15_y_{d_Stage+4_1_0_3_{i_Synth+Fiber_10.9900_1_1}}_{d_Stage+5_1_0_0_{i_Synth+Fiber_34.4800_1_1}}}_{m_Bounty+40-60_0_15_y_{d_Stage+4_1_0_0_{i_Synth+Reflex_14.2900_1_1}}_{d_Stage+5_1_0_0_{i_Synth+Reflex_33.3300_1_1}}}&s=1000000&start=start">
                            Full Synth/Mecha/Tek Set</a>:
                    </td>
                    <td>
                        The Synth, Mecha, and Tek sets all have the same drop rates on different bounty rotations.
                        You'll probably get a full set of each just running Orb Vallis bounties for other stuff.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=All+Corrupted+Mods_{m_Derelict+Exterminate_0_5_y_{d_Vault_1_0_0_{i_Spoiled+Strike_4.1700_1_1}_{i_Corrupt+Charge_4.1700_1_1}_{i_Hollow+Point_4.1700_1_1}_{i_Magnum+Force_4.1700_1_1}_{i_Tainted+Clip_4.1700_1_1}_{i_Critical+Delay_4.1700_1_1}_{i_Heavy+Caliber_4.1700_1_1}_{i_Tainted+Mag_4.1700_1_1}_{i_Vile+Precision_4.1700_1_1}_{i_Narrow+Minded_4.1700_1_1}_{i_Fleeting+Expertise_4.1700_1_1}_{i_Blind+Rage_4.1700_1_1}_{i_Overextended_4.1700_1_1}_{i_Tainted+Shell_4.1700_1_1}_{i_Vicious+Spread_4.1700_1_1}_{i_Burdened+Magazine_4.1700_1_1}_{i_Anemic+Agility_4.1700_1_1}_{i_Vile+Acceleration_4.1700_1_1}_{i_Frail+Momentum_4.1700_1_1}_{i_Critical+Deceleration_4.1700_1_1}_{i_Creeping+Bullseye_4.1700_1_1}_{i_Transient+Fortitude_4.1700_1_1}_{i_Depleted+Reload_4.1700_1_1}}}&start=start">
                            All Corrupted Mods</a>:
                    </td>
                    <td>
                        This is why trying to obtain all the corrupted mods without trading is crazy.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Profit-Taker:+All+Mods_{m_Profit-Taker+Phase+1_0_5_y_{d_Complete_1_0_0_{i_Quick+Reload_15.0000_1_1}_{i_Deadly+Efficiency_1.2500_1_1}_{i_Strain+Eruption_1.2500_1_1}}}_{m_Profit-Taker+Phase+2_0_2_y_{d_Complete_1_0_0_{i_Resolute+Focus_15.0000_1_1}_{i_Arch-Gun+Ace_1.2500_1_1}_{i_Strain+Fever_1.2500_1_1}}}_{m_Profit-Taker+Phase+3_0_5_y_{d_Complete_1_0_0_{i_Marked+Target_15.0000_1_1}_{i_Sabot+Rounds_1.2500_1_1}_{i_Strain+Infection_1.2500_1_1}}}_{m_Profit-Taker+Phase+4_0_10_y_{d_Complete_1_0_0_{i_Ammo+Chain_17.1400_1_1}_{i_Critical+Focus_1.4300_1_1}_{i_Strain+Consume_1.4300_1_1}}}&start=start">
                            Profit-Taker: All Mods</a>:
                    </td>
                    <td>
                        <p>
                            Getting all of the new mods from the Profit-Taker heist without trading is a pretty grim prospect.
                        </p>
                        <p>
                            For time estimates, I'm just guessing rough best-case scenarios of 5, 2, 5, and 10 minutes for each phase, respectively.
                        </p>
                </tr>
            </table>
            <h2 id="Relics">Relics</h2>
            <p>
                The transition from the old Void Key system to Relics was always less about reducing grind and more
                about increasing gameplay variety. Personally, I don't miss spending twelve straight hours in T3
                Survival, like, at all.
            </p>
            <p>
                Giving newly released Relics a dedicated mission with high drop rates is great and I wish they did that
                with more Relics. It's way better than <s>Void Fatigue</s> Xini Fatigue.
            </p>
            <p>
                That being said, Relic supply is still usually the bottleneck.  You can stockpile Void Traces but you
                can't stockpile newly released Relics.  So refining Relics to Radiant for the uncommon reward, which
                almost doubles the chances, is still worth it.
            </p>
            <table class="notes">
                <tr>
                    <td>
                        <a href="?m=Radshare_{m_Fissure_0_0_y_{d_Crack+Relic_4_0_0_{i_Rare_10.0000_1_1}}}&start=start">
                            Radshare</a>:
                    </td>
                    <td>
                        Radiant shares aren't bad on average. However, I've personally seen it take 20 radshares to get
                        the rare, which put that particular run in the 99.98th percentile.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Solo+Radiant_{m_Fissure_0_0_y_{d_Crack+Relic_1_0_0_{i_Rare_10.0000_1_1}}}&start=start">
                            Solo Radiant</a>:
                    </td>
                    <td>
                        And this is why you find Radiant shares.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Uncommon+Intact+Share_{m_Fissure_0_0_y_{d_Crack+Relic_4_0_0_{i_Uncommon_11.0000_1_1}}}&start=start">
                            Uncommon Intact Share</a>:
                    </td>
                    <td>
                        If you just want an uncommon reward, is it still worth it to refine the relic to Radiant?
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Uncommon+Radshare_{m_Fissure_0_0_y_{d_Crack+Relic_4_0_0_{i_Uncommon_20.0000_1_1}}}&start=start">
                            Uncommon Radshare</a>:
                    </td>
                    <td>
                        ...Probably.
                    </td>
                </tr>
                <!-- no current vaulted relics
                <tr>
                    <td>
                        <a href="?m=Three+Axi+S3+Relics+Mot_{m_Mot_0_0_y_{d_Rotation+C_1_0_20_{i_Axi+S3_11.1100_1_3}}}&start=start">
                            Three Axi S3 Relics (Mot)</a>:
                    </td>
                    <td>
                        The vaulted relics drop only in the Void, so your options for efficient farming are limited.
                        This is how long it takes to get enough for the average number of necessary Radiant shares.
                    </td>
                </tr>
                -->
                <tr>
                    <td>
                        <a href="?m=Three+Axi+C3/G1+Relics+(Bounties)_{m_Bounty+40-60_0_3_y_{d_Stage+2,3_2_0_3_{i_Axi+C3/G1_33.0400_1_3}}_{d_Stage+4_1_0_3_{i_Axi+C3/G1_25.6800_1_1}}_{d_Stage+5_1_0_3_{i_Axi+C3/G1_38.7800_1_1}}}&start=start">
                            Three Axi C3/G1 Relics (Bounties)</a>:
                    </td>
                    <td>
                        The new Axi relics have a very nice drop rate in the Cetus bounties, assuming you can catch the
                        right rotation.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Three+Neo+G1+Relics+(Bounties)_{m_Bounty+30-50_0_3_y_{d_Stage+2,3_2_0_3_{i_Axi+C3/G1_15.9600_1_3}}_{d_Stage+4_1_0_3_{i_Axi+C3/G1_15.6300_1_1}}_{d_Stage+5_1_0_3_{i_Axi+C3/G1_35.7100_1_1}}}&start=start">
                            Three Neo G1 Relics (Bounties)</a>:
                    </td>
                    <td>
                        Some of the new Neo relics are also relatively easy to get in Cetus bounties.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Meso+R1+Relic+(IO+Defense)_{m_Io+Defense_0_0_y_{d_Rotation+A_2_0_5_{i_Meso+R1_12.5000_1_1}}}&start=start">
                            Meso R1 Relic (IO Defense)</a>:
                    </td>
                    <td>
                        Getting one is not bad on average but the outliers are a killer.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=100+Void+Traces_{m_Quick+Fissure_0_5_y_{d_Crack+Relic_1_0_0_{i_Void+Trace_100.0000_6-30_100}}}&s=1000000&start=start">
                            100 Void Traces</a>:
                    </td>
                    <td>
                        How long does it take to get 100 Void Traces?
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=1000+Void+Traces+w/+Booster_{m_Quick+Fissure_0_5_y_{d_Crack+Relic_1_0_0_{i_Void+Trace_100.0000_12-60,2_1000}}}&s=1000000&start=start">
                            1000 Void Traces with a Booster</a>:
                    </td>
                    <td>
                        How about 1000 Void Traces with a 2x Resource Booster?
                    </td>
                </tr>
            </table>
            <h2 id="Arbitrations">Arbitrations</h2>
            <p>
                The drop table and rotation pattern is the same for all Arbitration missions regardless of mission type.
                However, time estimates will vary based on which mission you're doing and how long you go for.
            </p>
            <p>
                The endless C rotation means your time efficiency goes up the longer you run each mission, but you're
                going to have to pick some cutoff for the simulation to work with.
            </p>
            <p>
                So far I've only tried survival and interception.  Most of the other game modes seem to be bugged in
                some way that makes them take much longer to get the same number of rotations.
            </p>
            <table class="notes">
                <tr>
                    <td>
                        <a href="?m=Arbitration+Mods+(Survival+30m)_{m_Survival_0_0_y_{d_Rotation+A_1_0_10_{i_Sharpshooter_2.0000_1_1}_{i_Vigorous+Swap_2.0000_1_1}_{i_Rolling+Guard_2.0000_1_1}_{i_Adaptation_2.0000_1_1}}_{d_Rotation+B_1_0_10_{i_Sharpshooter_2.5000_1_1}_{i_Vigorous+Swap_2.5000_1_1}_{i_Rolling+Guard_2.5000_1_1}_{i_Adaptation_2.5000_1_1}}_{d_Rotation+C_1_0_10_{i_Sharpshooter_3.5000_1_1}_{i_Vigorous+Swap_3.5000_1_1}_{i_Rolling+Guard_3.5000_1_1}_{i_Adaptation_3.5000_1_1}}}&start=start">
                            Arbitration Mods (Survival 30 minutes)</a>:
                    </td>
                    <td>
                        Doing a Survival for 30 minutes gives you one A, one B, and one C rotation.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Arbitration+Mods+(Survival+1h)_{m_Survival_0_0_y_{d_Rotation+A_1_0_10_{i_Sharpshooter_2.0000_1_1}_{i_Vigorous+Swap_2.0000_1_1}_{i_Rolling+Guard_2.0000_1_1}_{i_Adaptation_2.0000_1_1}}_{d_Rotation+B_1_0_10_{i_Sharpshooter_2.5000_1_1}_{i_Vigorous+Swap_2.5000_1_1}_{i_Rolling+Guard_2.5000_1_1}_{i_Adaptation_2.5000_1_1}}_{d_Rotation+C_4_0_10_{i_Sharpshooter_3.5000_1_1}_{i_Vigorous+Swap_3.5000_1_1}_{i_Rolling+Guard_3.5000_1_1}_{i_Adaptation_3.5000_1_1}}}&start=start">
                            Arbitration Mods (Survival 1 hour)</a>:
                    </td>
                    <td>
                        Doing a Survival for an hour gives you one A, one B, and four C rotations.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Arbitration+Mods+(Survival+2h)_{m_Survival_0_0_y_{d_Rotation+A_1_0_10_{i_Sharpshooter_2.0000_1_1}_{i_Vigorous+Swap_2.0000_1_1}_{i_Rolling+Guard_2.0000_1_1}_{i_Adaptation_2.0000_1_1}}_{d_Rotation+B_1_0_10_{i_Sharpshooter_2.5000_1_1}_{i_Vigorous+Swap_2.5000_1_1}_{i_Rolling+Guard_2.5000_1_1}_{i_Adaptation_2.5000_1_1}}_{d_Rotation+C_10_0_10_{i_Sharpshooter_3.5000_1_1}_{i_Vigorous+Swap_3.5000_1_1}_{i_Rolling+Guard_3.5000_1_1}_{i_Adaptation_3.5000_1_1}}}&start=start">
                            Arbitration Mods (Survival 2 hours)</a>:
                    </td>
                    <td>
                        Doing a Survival for two hours gives you one A, one B, and ten C rotations.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Arbitration+Mods+(Interception+1h)_{m_Interception_0_0_y_{d_Rotation+A_1_0_8_{i_Sharpshooter_2.0000_1_1}_{i_Vigorous+Swap_2.0000_1_1}_{i_Rolling+Guard_2.0000_1_1}_{i_Adaptation_2.0000_1_1}}_{d_Rotation+B_1_0_8_{i_Sharpshooter_2.5000_1_1}_{i_Vigorous+Swap_2.5000_1_1}_{i_Rolling+Guard_2.5000_1_1}_{i_Adaptation_2.5000_1_1}}_{d_Rotation+C_5_0_8_{i_Sharpshooter_3.5000_1_1}_{i_Vigorous+Swap_3.5000_1_1}_{i_Rolling+Guard_3.5000_1_1}_{i_Adaptation_3.5000_1_1}}}&start=start">
                            Arbitration Mods (Interception 1h)</a>:
                    </td>
                    <td>
                        With a good team you can get about 14 rounds of Interception done in an hour, which gives you
                        one A, one B, and five C rotations.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Aura+Forma+(Interception+1h)_{m_Interception_0_0_y_{d_Rotation+A_1_0_8_{i_Aura+Forma_1.5000_1_1}}_{d_Rotation+B_1_0_8_{i_Aura+Forma_2.0000_1_1}}_{d_Rotation+C_5_0_8_{i_Aura+Forma_2.5000_1_1}}}&s=1000000&start=start">
                            Aura Forma (Interception 1h)</a>:
                    </td>
                    <td>
                        You're probably looking at around 6 hours of Arbitration per Aura Forma.
                    </td>
                </tr>
            </table>
            <h2 id="Rivens">Rivens</h2>
            <p>
                Before you get too worked up over the outrageous averages on some of the Riven examples, bear in mind
                this fact:
            </p>
            <p>
                Rolling one Riven 50 times has the same odds as rolling 5 similar Rivens 10 times each.
            </p>
            <p>
                Given the results in some of the Riven Roll examples here, I highly recommend going the latter route:
                Just putting up to 10 rolls into Rivens as you get them and moving on, saving more than 50% of your
                Kuva. You're bound to get some "acceptable" Rivens you can use while waiting for that big roll.
            </p>
            <table class="notes">
                <tr>
                    <td>
                        <a href="?m=90+Rivens_{m_Sortie_0_0_y_{d_Complete_1_0_0_{i_Riven_27.9000_1_90}}}&start=start">
                            90 Rivens</a>:
                    </td>
                    <td>
                        How many Sorties does it take to fill your Riven collection to capacity? This one's interesting,
                        as it's very close to a normal distribution
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Riven+for+a+Specific+Rifle_{m_Sortie_0_0_y_{d_Complete_1_0_0_{i_One+of+64+possible+Rifle+Rivens_0.1061_1_1}}}&start=start">
                            Riven for a Specific Rifle</a>:
                    </td>
                    <td>
                        How many Sorties does it take to get a Riven for your favorite non-shotgun primary, out of 64
                        possibilities as of November 2018?
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Basic+Damage+Gun+Riven_{r_Riven+Roll_g_{c_Damage_-1_-1_n-ddd--p-p-pppp-pndnpppd-dddnnn}}&s=100000&start=start">
                            Basic Damage Gun Riven</a>:
                    </td>
                    <td>
                        Just a basic damage Riven for a gun isn't too hard to roll.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Decent+Melee+Riven_{r_Riven+Roll_m_{c_Decent_-1_-1_-pdddnnpppdppppn--d--p-dp-dpd--}}&s=100000&start=start">
                            Decent Melee Riven</a>:
                    </td>
                    <td>
                        A decent Melee Riven is also not hard to roll if you're not picky.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Crit+or+Status+Melee+Riven_{r_Riven+Roll_m_{c_Crit_-1_-1_-pdddnnppPdppppn--d--p-dp-ddn--}_{c_Status_-1_-1_-pdddnnpdnndpppn--d--p-dp-pPp--}}&s=100000&start=start">
                            Crit or Status Melee Riven</a>:
                    </td>
                    <td>
                        When rolling a Zaw Riven, I get the best results by rolling until I get either good crit stats
                        or good status stats, and then building a Zaw accordingly.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Status+Gun_Riven_{r_Riven+Roll_g_{c_Status_-1_-1_n-ddd--p-d-dppp-pnnnpppn-npPpnn}}&s=100000&start=start">
                            Status Gun Riven</a>:
                    </td>
                    <td>
                        If you're picky about your status Riven then it may take a few rolls.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Crit+Gun+Riven_{r_Riven+Roll_g_{c_Crit_-1_-1_n-ddd--p-P-pppp-dndnpppd-nddnnn}}&s=100000&start=start">
                            Crit Gun Riven</a>:
                    </td>
                    <td>
                        Even more if you're you're picky about your crit Riven.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Godlike+Lanka+Riven_{r_Riven+Roll_g_{c_Hallelujah_-1_-1_n-nnn--d-p-ppdd-ddndpddn-dnnnnn}}&s=50000&start=start">
                            Godlike Lanka Riven</a>:
                    </td>
                    <td>
                        This is why players pay a very high price for these.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Godlike+Vectis+Riven_{r_Riven+Roll_g_{c_Damage,+-Mag+Cap_-1_1_d-ddd--p-p-pppp-pddnppdd-pddddd}}&s=50000&start=start">
                            Godlike Vectis Riven</a>:
                    </td>
                    <td>
                        If you absolutely have to have negative magazine capacity.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Perfect+Rubico+Riven_{r_Riven+Roll_g_{c_Crits+for+days_-1_-1_n-ddd--d-P-Pppp-dnddpddd-dnnnnn}}&s=50000&start=start">
                            Perfect Rubico Riven</a>:
                    </td>
                    <td>
                        Getting super ridiculous now.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=God's+God's+Lanka+Riven_{r_Riven+Roll_g_{c_PICKY+AF_3_1_d-ddd--d-p-Pdpp-ddddPddd-dddddn}}&s=500&start=start">
                            God's God's Lanka Riven</a>:
                    </td>
                    <td>
                        Someone told me this is the Lanka Riven to shoot for.  They are crazy.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Riven+with+Exact+Stats_{r_Riven+Roll_g_{c_IT+HAS+TO+BE+THESE_3_1_d-ddd--d-P-Pddd-ddddPddd-dddddn}}&s=1000&start=start">
                            Riven with Exact Stats</a>:
                    </td>
                    <td>
                        <p>
                            Okay, so you're going to have to accept some wiggle room in the Riven stats you're looking
                            for. If you absolutely must have a Riven with three specific positive stats and one
                            specific negative stat, then you will be rolling it for an astronomically long time.
                        </p>
                        <p>
                            Honestly, this is mostly here as a joke. It's just past the point where the simulation
                            really starts bogging down on my laptop. Still, it's interesting to watch each data point
                            appear one-by-one in slow motion after hundreds of thousands of rolls.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Exact+Stats+with+Locking_{r_Riven+Roll_g_{c_CC_-1_-1_d-ddd--d-P-dddd-dddddddd-dddddd}_{c_CD_-1_-1_d-ddd--d-d-Pddd-dddddddd-dddddd}_{c_MS_-1_-1_d-ddd--d-d-dddd-ddddPddd-dddddd}}_{r_Riven+Roll_g_{c_CC_-1_-1_d-ddd--d-P-dddd-dddddddd-dddddd_9}}_{r_Riven+Roll_g_{c_CD_-1_-1_d-ddd--d-L-Pddd-dddddddd-dddddd}_{c_MS_-1_-1_d-ddd--d-L-dddd-ddddPddd-dddddd}}_{r_Riven+Roll_g_{c_CD_-1_-1_d-ddd--d-L-Pddd-dddddddd-dddddd_9}}_{r_Riven+Roll_g_{c_MS_3_-1_d-ddd--d-L-Lddd-ddddPddd-dddddd_10}}_{r_Riven+Roll_g_{c_Z_3_1_d-ddd--d-L-Lddd-ddddLddd-dddddn}}&s=50000&start=start">
                            Riven with Exact Stats (Experimental Stat Locking)</a>:
                    </td>
                    <td>
                        <p>
                            <strong class="warn">This is totally an experiment, and does not reflect how Rivens actually work in the game.</strong>
                        </p>
                        <p>
                            The idea is to roll a particular stat 10 times to lock it, and then roll another stat 10
                            times to lock it, etc, until you have rolled all three positive stats and one negative stat.
                        </p>
                        <p>
                            There are some edge cases not accounted for in the scenario I've built here, but they only
                            negligibly affect the final result.
                        </p>
                        <p>
                            There are a number of experimental simulator features enabled for just this scenario,
                            including stat locking itself.  They don't have full documentation yet because they're
                            pretty out there.
                        </p>
                    </td>
                </tr>
            </table>
            <h2 id="Misc">Misc</h2>
            <p>

            </p>
            <table class="notes">
                <tr>
                    <td>
                        <a href="?m=Shedu_{e_Symbilyst_0_0_y_{d_Kill_1_0_0_0_{i_Barrel_1.0000_1_1}_{i_Chassis_1.0000_1_1}_{i_Handle_1.0000_1_1}_{i_Receiver_1.0000_1_1}}}&s=1000000">
                            All Shedu Parts</a>:
                    </td>
                    <td>
                        This has got to be wrong.  I have 3/4 parts and I'm definitely not close to killing 200 of these suckers.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=All+Ropalyst+Drops_{m_Ropalyst+Assassiate_0_0_y_{d_Mod+Drop_1_0_0_{i_Amalgam+Furax+Body+Count_20.0000_1_1}_{i_Amalgam+Ripkas+True+Steel_20.0000_1_1}_{i_Amalgam+Argonak+Metal+Auger_20.0000_1_1}_{i_Amalgam+Daikyu+Target+Acquired_20.0000_1_1}_{i_Amalgam+Javlok+Magazine+Warp_20.0000_1_1}}_{d_Blueprint+Drop_1_0_0_{i_Wisp_22.5600_1_1}_{i_Helmet_25.8100_1_1}_{i_Chassis_25.8100_1_1}_{i_System_25.8100_1_1}}}&start=start">
                            All Ropalyst Drops</a>:
                    </td>
                    <td>
                        Depending on how fast you can do the fight, this isn't a total slog.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Miter_{m_Ceres+Ass_0_10_y_{d_Kill+Krill_1_0_0_{i_Barrel_16.6700_1_1}_{i_Blade_16.6700_1_1}_{i_Handle_16.6700_1_1}_{i_Chassis_16.6700_1_1}_{i_Blueprint_16.6700_1_1}}}&start=start">
                            Miter</a>:
                    </td>
                    <td>
                        I bet you forgot about farming all five pieces of this thing.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=All+Hydrolyst+arcanes_{e_Hydrolyst_0_0_y_{d_Kill_1_0_0_0_{i_Trickery_20.2400_1_21}_{i_Velocity_16.7900_1_21}_{i_Rage_12.7400_1_21}_{i_Arachne_12.7400_1_21}_{i_Avenger_11.2400_1_21}_{i_Fury_11.2400_1_21}_{i_Grace_5.0000_1_21}_{i_Barrier_5.0000_1_21}_{i_Energize_5.0000_1_21}}}&s=500000&start=start">
                            All Hydrolyst arcanes</a>:
                    </td>
                    <td>
                        Honestly you're probably better off waiting for the next Scarlet Spear event.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Imperator+Vandal_{m_Fomorian_0_0_y_{d_Complete_1_0_0_{i_Barrel_11.2800_1_1}_{i_Receiver_11.2800_1_1}_{i_Blueprint_38.7200_1_1}}}&start=start">
                            Imperator Vandal</a>:
                    </td>
                    <td>
                        Not that bad on average.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=All+Granum+Void+Drops_{m_Granum+Void_0_0_y_{d_Rotation+C_1_0_0_0_{i_Stropha+Barrel_22.2200_1_1}_{i_Stropha+Blade_22.2200_1_1}_{i_Stahlta+Receiver_22.2200_1_1}_{i_Velox+Barrel_22.2200_1_1}_{i_Protea+Neuroptics_11.1100_1_1}}}_{m_Extended+Granum+Void_0_0_y_{d_Rotation+C_1_0_0_0_{i_Stropha+Receiver+_29.6300_1_1}_{i_Stahlta+Stock_29.6300_1_1}_{i_Velox+Receiver_29.6300_1_1}_{i_Protea+Chassis_11.1100_1_1}}}_{m_Nightmare+Granum+Void_0_0_y_{d_Rotation+C_1_0_0_0_{i_Mortuus+Shoulder+Guard+_29.6300_1_1}_{i_Stropha+Stock_29.6300_1_1}_{i_Stahlta+Barrel_29.6300_1_1}_{i_Protea+Systems_11.1100_1_1}}}&start=start">
                            All Granum Void Drops</a>:
                    </td>
                    <td>
                        The actual "mission" takes very little time, it's all the hanging around a Corpus ship waiting
                        for the Treasurer that makes this a grind
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Wolf+Sledge_{e_Wolf_0_0_y_{d_Kill_1_0_0_{i_Handle_13.5520_1_1}_{i_Head_13.5520_1_1}_{i_Blueprint_3.9480_1_1}_{i_Motor_3.9480_1_1}}}&start=start">
                            Wolf Sledge</a>:
                    </td>
                    <td>
                        <p>
                            The drop table is misleading because it's on top of just a 35% chance to drop any part at all.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=All+Razorback+Drops_{e_Razorback_0_0_y_{d_Kill_1_0_0_{i_Gorgon+Wraith+Blueprint_18.9700_1_1}_{i_Gorgon+Wraith+Barrel_18.9700_1_1}_{i_Gorgon+Wraith+Receiver_18.9700_1_1}_{i_Gorgon+Wraith+Stock_18.9700_1_1}_{i_Bore_5.5300_1_1}_{i_Piercing+Caliber_5.5300_1_1}_{i_Breach+Loader_5.5300_1_1}_{i_Augur+Strike_5.5300_1_1}_{i_Magma+Chamber_1.0100_1_1}_{i_Searing+Steel_1.0100_1_1}}}&start=start">
                            All Razorback Drops</a>:
                    </td>
                    <td>
                        The two ultra-rare mods that you can only obtain from the Razorback are what make this painful.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=All+Shadow+Stalker+Drops_{e_I+AM+YOUR+RECKONING_0_0_y_{d_Kill_1_0_0_{i_Scimitar+Engines+BP_1.0050_1_1}_{i_Broken+War+BP_2.7650_1_1}_{i_Dread+BP_37.9400_1_1}_{i_Despair+BP_2.7650_1_1}_{i_Hate+BP_2.7650_1_1}_{i_War+BP_2.7650_1_1}}}&start=start">
                            All Shadow Stalker Drops</a>:
                    </td>
                    <td>
                        This particular scenario ends up having the highest Excess Kurtosis of all the examples, which
                        explains the surprising number of players still missing some Stalker drops after playing for
                        years.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Broken+War+Parts_{e_Conculyst_0_0_y_{d_Kill_1_0_0_{i_War+Hilt+BP_0.5000_1_2}_{i_War+Blade+BP_0.5000_1_1}}}&start=start">
                            Broken War Parts</a>:
                    </td>
                    <td>
                        Again, bring a loot frame to farm Conculysts.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Braton+and+Lato+Vandal_{m_Elite+Onslaught_0_0_y_{d_Rotation+A_2_0_5_{i_Lato+Receiver_2.0100_1_1}}_{d_Rotation+B_1_0_5_{i_Braton+Barrel_4.4200_1_1}_{i_Braton+Receiver_4.4200_1_1}_{i_Lato+BP_2.0100_1_1}}_{d_Rotation+C_1_0_5_{i_Braton+Stock_2.2100_1_1}_{i_Braton+BP_2.0100_1_1}_{i_Lato+Barrel_2.2100_1_1}}}&start=start">
                            Braton and Lato Vandal</a>:
                    </td>
                    <td>
                        Get ready to cry.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=All+Kuva+Lich+Weapons_{e_Kuva+Lich_0_0_y_{d_Kill_1_0_0_1_{i_Karak_6.2500_1_1}_{i_Quartakk_6.2500_1_1}_{i_Ogris_6.2500_1_1}_{i_Kohm_6.2500_1_1}_{i_Tonkor_6.2500_1_1}_{i_Drakgoon_6.2500_1_1}_{i_Stubba_6.2500_1_1}_{i_Kraken_6.2500_1_1}_{i_Brakk_6.2500_1_1}_{i_Chakkurr_6.2500_1_1}_{i_Shildeg_6.2500_1_1}_{i_Ayanga_6.2500_1_1}_{i_Seer_6.2500_1_1}_{i_Hind_6.2500_1_1}_{i_Nukor_6.2500_1_1}_{i_Bramma_6.2500_1_1}}}&start=start">
                            All Kuva Lich Weapons</a>:
                    </td>
                    <td>
                            At at least a couple of hours per try, this is a challenger for heaviest grind.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Legendary+Core_{m_Sortie_0_0_y_{d_Complete_1_0_0_{i_Legendary+Core_0.1800_1_1}}}&start=start">
                            Legendary Core</a>:
                    </td>
                    <td>
                        It's legendary for a reason.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=Xiphos_{m_Tier+1+Sabotage_0_10_y_{d_Rotation+C_1_0_0_{i_Fuselage_0.5000_1_1}}}_{m_Tier+2+Sabotage_0_10_y_{d_Rotation+C_1_0_0_{i_Engines_0.5000_1_1}}}_{m_Tier+3+Sabotage_0_10_y_{d_Rotation+C_1_0_0_{i_Avionics_0.5000_1_1}}}&start=start">Xiphos</a>:
                    </td>
                    <td>
                        Possibly the most ludicrous grind in the game.
                    </td>
                </tr>
                <tr>
                    <td>
                        <a href="?m=All+Necramech+Mods_{m_All+3+Isolation+Vaults_0_30_y_{d_Tier+1_1_0_0_0_{i_Redirection_7.5880_1_1}_{i_Steel+Fiber_2.2110_1_1}_{i_Thrusters_0.2010_1_1}}_{d_Tier+2_1_0_0_0_{i_Reach_2.5290_1_1}_{i_Blitz_2.5290_1_1}_{i_Slipstream_2.5290_1_1}_{i_Continuity_2.2110_1_1}_{i_Seismic+Wave_0.2010_1_1}}_{d_Tier+3_3_0_0_0_{i_Fury_7.5880_1_1}_{i_Stretch_1.0600_1_1}_{i_Hydraulics_1.1060_1_1}_{i_Streamline_0.2010_1_1}}}&s=100000&start=start">All Necramech Mods</a>:
                    </td>
                    <td>
                        Oh man there's a new contender for ridiculous grind, and it's the Necramech mod set.
                        It takes 30+ minutes just to run all three tiers once.
                    </td>
                </tr>
            </table>

            <h1 id="ToDo">To Do</h1>
            <ul>
                <li>
                    I'd like to be able to make some kind of scenario that combines Relic Farming, Void Trace Farming,
                    and Fissures into one grand total, but the process of <i>consuming</i> items and going backwards in the
                    mission sequence when you run out of something makes things more complicated. A scenario that
                    combines Kuva Farming and Riven Rolling is tough for the same reason.
                </li>
                <li>
                    When you switch Riven types I wish it would keep any selections under the stat list that are common
                    between the two types rather than just wiping it all out and starting fresh.
                </li>
                <li>
                    A whole bunch of performance optimizations, probably.
                </li>
                <li>
                    I'm not sure the Items Required and Drop Events Required fields need to be here.  I'm pretty
                    sure they're always set to <strong>0</strong> on every example, meaning all Items and Drop Events
                    are required.
                </li>
                <li>
                    Make the statistics section update in place rather than rebuilding the entire section every time.
                </li>
                <li>
                    Enhance the chart so it doesn't have to start at zero on the left.  Right now, distributions with
                    a high average and small standard deviation end up as indistinguishable spikes all the way to the
                    right.
                </li>
            </ul>


            <h1 id="KnownIssues">Known Issues</h1>
            <ul>
                <li>
                    The charts don't work in Microsoft Edge. Don't use Edge.
                </li>
                <li>
                    Sometimes the Generate Link pop-up doesn't disappear correctly on Chrome if you switch tabs at the
                    wrong time.  Shrug Emoji.
                </li>
                <li>
                    A Riven scenario runs somewhere between a hundred and a thousand times slower than a mission or
                    enemy scenario with a similar average. It's Javascript, there's only so much optimization you can
                    do.
                </li>
                <li>
                    Running a lot of simulations on a mobile device will really tear your battery a new one. That's
                    just the way it is.
                </li>
                <li>
                    The simulation pauses if the browser tab doesn't have focus.  I'm not using WebWorker because I
                    want everything to be in one file.
                </li>
            </ul>
        </div>
    </div>

    <div class="footerContainer">
        <div>
            <img src="https://i.imgur.com/b5pNXKU.png" srcset="https://i.imgur.com/z6U8Oxs.png 2x"/>
        </div>
        <div>
            Buff00n
        </div>
        <div>
            <a href="https://github.com/buff0000n/rngsim">Source</a>
            <a href="https://github.com/buff0000n/rngsim/issues/1">Feedback</a>
        </div>
        <div>
            v1.8.9: 2021-04-10
        </div>
    </div>
</div>
</body>
</html>